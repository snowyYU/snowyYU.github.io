<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2016小小结</title>
    <url>/2017/01/10/2016%E5%B0%8F%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>2016年结束了，回头看来这年经历可真是丰富啊，没去考研，感觉整年都在弥补我的过错，现在想想都觉得我真是太废了，1月6号开始决定敲代码，翻开人生第一本代码书–超简单的headfirst-html。过年因为家庭问题也没有回家，初二便跑回学校，记得当时贝岗只有M记开门（而且还只有我最讨厌的香辣堡卖），真是对自己的惩罚，希望自己能多多记住这种感觉</p>
<h1 id="学习部分"><a href="#学习部分" class="headerlink" title="学习部分"></a>学习部分</h1><h2 id="总结下今年看的书"><a href="#总结下今年看的书" class="headerlink" title="总结下今年看的书"></a>总结下今年看的书</h2><h3 id="技术上"><a href="#技术上" class="headerlink" title="技术上"></a>技术上</h3><p>1.headfirst-html和css，自己看完的第一本代码书，按照示例敲出了第一个静态页面，现在想想真是挺适合入门的，讲的简单生动<br>2.headfirst-html5,这个看了一半，倒是对html5有了比较浅的了解<br>3.javascript高级程序设计，这个看了一半，必读书籍，新的一年准备和犀牛书再啃一遍<br>4.css权威教程，读了大半，也是当做工具书，需要就去查，很详细<br>5.jq基础，挑着读了些，很多时候需要用到时跑去查找</p>
<h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><p>1.中国缺了一味药，感觉有些心酸<br>2.时间简史，看了一点点，感觉还是值得一看，全民科普类书籍<br>3.<a href="http://www.cnblogs.com/yangpf/p/4148488.html">相对论并非遥不可及</a>，写的相当赞，我竟然看懂啦<br>4.常识，托马斯潘恩的，据说是美国独立战争的反动小册子，感觉看着翻译的版本有点怪<br>5.知乎上收藏了一大把的东西</p>
<h2 id="学到的技术"><a href="#学到的技术" class="headerlink" title="学到的技术"></a>学到的技术</h2><p>1.前端基础html,css相比较看的较多，js和jq就不够了，自己明白js很重要，<br>2.bootstrap，这个也只能算了解，其核心网格系统也只是勉强会用<br>3.angular，想想听到老大说用angular搭建项目时的一脸懵逼，只能硬着头皮上了，现在也只能说是刚入门，框架自身变化也快，此外第三方的库，angular-ui，ui-router，oclazyload，ng-grid也多少了解些<br>4.ui-grid这个拿出来单独说，因为这个要替代ng-grid了，而且其功能更强大，我也打算将angular项目中的表格替换为ui-grid<br>5.Git，只会些简单的命令，倒是对其了解了些<br>6.gulp，倒是自己尝试配了些简单的命令，</p>
<blockquote>
<p>这一年接触的东西不少，深究起来真正懂的一个都没有，这也是下年需要改进的地方</p>
</blockquote>
<h1 id="生活部分"><a href="#生活部分" class="headerlink" title="生活部分"></a>生活部分</h1><p>啊哈，还是单身单身，欣慰的是毕业后能和大学好盆友暂时住在一起，延续了些大学的味道，嗯，尝试做了很多次饭（虽然是最简单的烤面包片加鸡蛋），把自己的房间认真装了下，拍死了不少小强，开始独立自己买衣服，年末开始锻炼身体了</p>
<p>当然，这一年还有个大事件就是我毕业啦，感觉吧，不开心</p>
<h1 id="工作部分"><a href="#工作部分" class="headerlink" title="工作部分"></a>工作部分</h1><p>在安正实习了下，跑到海豚啦，氛围很好，师兄很赞，还有一堆大学的小伙伴</p>
<h1 id="吸取的教训"><a href="#吸取的教训" class="headerlink" title="吸取的教训"></a>吸取的教训</h1><p>最大的教训就是最后没去考研，一直以来觉得自己可以坦然面对一些事，现在发现还真是高估了自己，发觉自己还是太容易受环境影响，内心对未知有种惧怕，自己很多时候是准备不足。这种挫败感真是太大了，自己远不如想象的成熟</p>
<h1 id="新一年给自己"><a href="#新一年给自己" class="headerlink" title="新一年给自己"></a>新一年给自己</h1><p>js很重要，新的一年要重新弄下，<br>1.身体很重要，多跑跑步，可以的话，去健身房吧<br>2.英语<br>3.php，体验下世界上最好的语言</p>
]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>回顾</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular1.X页面间传值</title>
    <url>/2017/04/19/Angular1-X%E9%A1%B5%E9%9D%A2%E9%97%B4%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<p>页面间的传值还是很常见的，在此记录下我接触过的angular1.X版本页面间传值的例子</p>
<span id="more"></span>
<h1 id="使用ui-router"><a href="#使用ui-router" class="headerlink" title="使用ui-router"></a>使用ui-router</h1><h2 id="1-html模板页中可直接写在ui-sref里"><a href="#1-html模板页中可直接写在ui-sref里" class="headerlink" title="1. html模板页中可直接写在ui-sref里"></a>1. html模板页中可直接写在ui-sref里</h2><p>比如</p>
<pre><code>ui-sref=&quot;app.operation.channel-overview(&#123;&#39;appId&#39;:&#39;&#123;&#123;item.appId&#125;&#125;&#39;,&#39;appName&#39;:&#39;&#123;&#123;item.appName&#125;&#125;&#39;&#125;)&quot;
</code></pre>
<p>相应的，ui-router中配置目的地url时需要拼接如下</p>
<pre><code>url: &#39;/channel-overview?appId&amp;appName&#39;
</code></pre>
<p>在目标控制器中取出来</p>
<pre><code>var appId=$stateParams.appId
</code></pre>
<blockquote>
<p>参数内容会在浏览器的url中显示出来，比较乱</p>
</blockquote>
<h2 id="2-使用-state-go"><a href="#2-使用-state-go" class="headerlink" title="2. 使用$state.go()"></a>2. 使用$state.go()</h2><h3 id="old"><a href="#old" class="headerlink" title="old"></a>old</h3><p>先讲下比较早的ui-router传参，有个很致命缺点就是url中不显示参数，刷新等操作会使页面丢失之前传过来的参数，如下</p>
<p> 1.router配置中标明参数的名字</p>
<pre><code>.state(&#39;state1&#39;, &#123;
url: &#39;/path/:id&#39;, // 这个地方用简单字符串
templateUrl: &#39;/path/to.html&#39;,
params: &#123;
obj: null // 这个地方就可以随便你用了. 因为这个参数没在state的url中体现出来
&#125;
&#125;).
</code></pre>
<p> 2.$state.go</p>
<pre><code>$state.go(&#39;state1&#39;, &#123;
id: &#39;22&#39;,
obj: &#123;
    key: &#39;value&#39;
&#125;
&#125;);
</code></pre>
<p>3.获取obj直接用</p>
<pre><code>$stateParams.obj
</code></pre>
<blockquote>
<p>不要用了</p>
</blockquote>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>忘记在哪个版本ui-router新增了如下方法，可保持url中的参数</p>
<p>1.$state</p>
<pre><code> $state.go(&quot;state&quot;,&#123;datas:&#123;ID:data1,NAME:data2&#125;&#125;)
</code></pre>
<p>2.配置router</p>
<pre><code>.state(&#39;state&#39;,&#123;
url:&#39;path/&#123;datas:json&#125;&#39;,
params:&#123;&#39;datas&#39;:null&#125;.
...
&#125;)
</code></pre>
<p>3.用$stateParam.datas来取</p>
<h1 id="基于factory的页面间传参"><a href="#基于factory的页面间传参" class="headerlink" title="基于factory的页面间传参"></a>基于factory的页面间传参</h1><blockquote>
<p>这个没试过，上链接</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/33565135">知乎angular页面间传参</a></p>
]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 小记</title>
    <url>/2019/08/27/MongoDB-%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>主要是记录下我学习 MongoDB 的过程和遇到的问题，以供后续的查阅和学习，持续改进吧</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这是官网安装页面，<a href="https://docs.mongodb.com/manual/installation/#tutorial-installation">MongoDB Install</a>。</p>
<p>有企业版和社区版的区分，基本是</p>
<p>我是 mac 系统，有 brew 和二进制文件两种安装方法</p>
<p>顺便说一下，MacOS 因为涉及到权限问题，需要用到 sudo 命令，或是设置 root 账户，然后用 su 命令切换用户</p>
<blockquote>
<p>附上官方启用 root 账户的说明，<a href="https://support.apple.com/zh-cn/HT204012">如何在 Mac 上启用 root 用户或更改 root 密码</a></p>
</blockquote>
<p><del>注意安装后需要创建一个数据库数据存储的文件夹</del></p>
<p><del><code>mkdir -p /data/db</code></del></p>
<p><del>如果运行 <code>ps -xa | grep mongod</code>，没有看到一个 <code>dbpath</code> 显式地告诉 mongod 查看该数据库位置的参数，并且你的 mongodb.conf 中没有数据库路径，那么默认数据存储位置就是如上</del></p>
<p>Mac 升级为 Catalina 系统后，根目录只有读的权限了，也就是不能在根目录创建 /data/db</p>
<p>两种解决方法</p>
<ol>
<li><p>使用 <code>mongod --dbpath=/Users/user/data/db</code> 这种，每次都指明数据存放路径的命令启动 mongodb</p>
</li>
<li><p>参考 <a href="https://stackoverflow.com/questions/58034955/read-only-file-system-when-attempting-mkdir-data-db-on-mac">stackoverflow</a> 第二条回答，使用 brew 启动<br><code>brew services start mongodb-community</code></p>
</li>
</ol>
<blockquote>
<p>顺便说 <code>cd /</code> 命令可以直接进入根目录<br><code>cd ~</code> 进入用户根目录</p>
</blockquote>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>因为我已经把 mongoDB 的路径加入了系统路径中，并且使用了默认的数据存放位置，所以可以直接，如果没做这两步的话，参考如下</p>
<blockquote>
<p><a href="https://docs.mongodb.com/guides/server/install/">MongoDB 配置</a></p>
</blockquote>
<pre><code>sudo mongod //启动
</code></pre>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>新开一个命令行工具，输入</p>
<pre><code>mongo
</code></pre>
<p>连接数据库，可以输入查询语句了</p>
<blockquote>
<p>自己的阿里云使用了 docker 版本的 mongodb，所以在这里记录下进入 docker 版本 mongodb 的命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mongotest_mongo_1 mongo <span class="comment"># docker exec -it #容器名 mongo</span></span><br></pre></td></tr></table></figure>


<h2 id="操作部分"><a href="#操作部分" class="headerlink" title="操作部分"></a>操作部分</h2><p>还能说啥，重中之重，多多练习</p>
<h2 id="用户的授权，创建，修改，查看用户"><a href="#用户的授权，创建，修改，查看用户" class="headerlink" title="用户的授权，创建，修改，查看用户"></a>用户的授权，创建，修改，查看用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择管理员用户</span></span><br><span class="line">use admin</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.auth(<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;pwd&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.createUser(user:<span class="string">&#x27;&#x27;</span>,<span class="built_in">pwd</span>:<span class="string">&#x27;&#x27;</span>,roles:[])</span><br><span class="line"><span class="comment"># 示例 db.createUser(&#123;user:&#x27;owner&#x27;,pwd:&#x27;yu321&#x27;,roles:[&#123;role:&#x27;dbOwner&#x27;,db:&#x27;filemanagedb&#x27;&#125;]&#125;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show users <span class="comment"># 查看当前数据库用户</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.system.users.find() // 查看所有用户</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/26215701">详情参考此文</a></p>
</blockquote>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>查看所有数据库</p>
<pre><code>&gt; show dbs
</code></pre>
<p>查看当前数据库的 collections (集合)</p>
<pre><code>&gt; show collections
</code></pre>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建或进入某个存在的数据库</p>
<pre><code>&gt; use &lt;name&gt;
</code></pre>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入一条数据</p>
<pre><code>&gt; db.collection.insertOne(&#123;&#125;)
</code></pre>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://docs.mongodb.com/manual/tutorial/getting-started/">MongoDB get start</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/44263728">小白必须懂的 MongoDB 的十大总结-MongoDB 的认识
</a></li>
</ul>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Linus 相关命令</title>
    <url>/2019/12/06/Linus-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>需要用到的时候常常忘记，与其每次去Google还不如自己好好做下记录，至少不用去Google了吧，哈哈</p>
<span id="more"></span>

<h1 id="文档型：文件相关命令"><a href="#文档型：文件相关命令" class="headerlink" title="文档型：文件相关命令"></a>文档型：文件相关命令</h1><blockquote>
<p>touch,cat,echo,rm,vi,cd</p>
</blockquote>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p><code>cd</code> 命令就不用多说了，进入某个目录下</p>
<ul>
<li><code>cd /</code> 为进入根目录下</li>
<li><code>ls</code> 列出当前目录下所有文件名称</li>
</ul>
<h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>查看当前文件目录完整路径</p>
<blockquote>
<p>复制当前目录到剪贴板，<code>pwd|pbcopy</code></p>
</blockquote>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>创建一个目录</p>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>移动一个文件或文件夹，也可用于更改文件名</p>
<blockquote>
<p><code>mv test.txt test</code> 将 test.txt 文件移动到当前目录下到test文件夹下</p>
</blockquote>
<blockquote>
<p><code>mv test.txt test1.txt</code> 将 test.txt 文件名改为test1.txt</p>
</blockquote>
<h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>一般用于服务器上的上传下载操作</p>
<ul>
<li>从服务器上下载文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp username@servername:/path/filename /var/www/local_dir（本地目录）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例如scp <a href="mailto:&#114;&#x6f;&#111;&#x74;&#64;&#49;&#57;&#50;&#46;&#49;&#x36;&#x38;&#46;&#x30;&#x2e;&#x31;&#x30;&#49;">&#114;&#x6f;&#111;&#x74;&#64;&#49;&#57;&#50;&#46;&#49;&#x36;&#x38;&#46;&#x30;&#x2e;&#x31;&#x30;&#49;</a>:/var/www/test.txt  把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录）</p>
</blockquote>
<ul>
<li>上传本地文件到服务器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /path/filename username@servername:/path   </span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>例如scp /var/www/test.php  <a href="mailto:&#x72;&#x6f;&#111;&#x74;&#64;&#49;&#x39;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#48;&#46;&#x31;&#48;&#x31;">&#x72;&#x6f;&#111;&#x74;&#64;&#49;&#x39;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#48;&#46;&#x31;&#48;&#x31;</a>:/var/www/  把本机/var/www/目录下的test.php文件上传到192.168.0.101这台服务器上的/var/www/目录中</p>
</blockquote>
<p> </p>
<ul>
<li>从服务器下载整个目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录）</span><br></pre></td></tr></table></figure>

<p>例如:scp -r <a href="mailto:&#x72;&#x6f;&#x6f;&#116;&#64;&#49;&#x39;&#50;&#x2e;&#49;&#54;&#56;&#x2e;&#x30;&#46;&#x31;&#48;&#x31;">&#x72;&#x6f;&#x6f;&#116;&#64;&#49;&#x39;&#50;&#x2e;&#49;&#54;&#56;&#x2e;&#x30;&#46;&#x31;&#48;&#x31;</a>:/var/www/test  /var/www/  </p>
<ul>
<li>上传目录到服务器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp  -r local_dir username@servername:remote_dir</span><br></pre></td></tr></table></figure>
<p>例如：scp -r test  <a href="mailto:&#x72;&#111;&#111;&#x74;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#46;&#x30;&#x2e;&#49;&#x30;&#49;">&#x72;&#111;&#111;&#x74;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#46;&#x30;&#x2e;&#49;&#x30;&#49;</a>:/var/www/   把当前目录下的test目录上传到服务器的/var/www/ 目录</p>
<h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>创建一个文件，注意区别 <code>mkdir</code> 命令</p>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>查看文件内容</p>
<blockquote>
<p>比如 <code>cat test.txt</code></p>
</blockquote>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>向文件中添加或覆盖内容</p>
<p><code>echo 1234 &gt;&gt; test.txt</code> 两个箭头表示向内容末尾添加内容</p>
<p><code>echo 1234 &gt; test.txt</code> 一个箭头表示覆盖内容</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除文件</p>
<ul>
<li>删除目录使用 <code>rm -r</code> 命令<blockquote>
<p>注意 <code>rm -rf</code> 是强制删除命令，慎用，会造成误删后无法恢复的问题</p>
</blockquote>
</li>
</ul>
<h2 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h2><p>用 <strong>vim</strong> 编辑器编辑文件</p>
<h1 id="功能型：压缩-解压，下载，远程"><a href="#功能型：压缩-解压，下载，远程" class="headerlink" title="功能型：压缩/解压，下载，远程"></a>功能型：压缩/解压，下载，远程</h1><blockquote>
<p>wget, tar, ssh</p>
</blockquote>
<h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>下载文件，命令后跟资源地址</p>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><h3 id="解压文件，-命令后跟文件名"><a href="#解压文件，-命令后跟文件名" class="headerlink" title="解压文件， 命令后跟文件名"></a>解压文件， 命令后跟文件名</h3><p><strong>tar zxvf</strong> 参数解释</p>
<ul>
<li><strong>z</strong> 用来解压 <strong>.gz</strong>后缀的文件，比如 <strong>apache-tomcat-9.0.17.tar.gz</strong></li>
<li><strong>x</strong> 代表解压缩</li>
<li><strong>v</strong> 代表显示所有的解压过程</li>
<li><strong>f</strong> 表示解压后的文件使用压缩包文件的名字，比如 </li>
<li><strong>apache-tomcat-9.0.17.tar.gz</strong> 使用 <strong>zxvf</strong> 参数解压后的文件名为 <strong>apache-tomcat-9.0.17</strong></li>
</ul>
<h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p><strong>tar zcvf</strong> 参数解释，<strong>c</strong> 代表压缩，其余解释和上文一致</p>
<blockquote>
<p>需要注意，<strong>tar zcvf</strong> 后跟两个参数，第一个参数为压缩后的文件名，第二个参数为需要被压缩的文件，例如把 <strong>apache-tomcat-9.0.17</strong> 压缩成 <strong>apache-tomcat.tar.gz</strong> 使用 <code>tar zcvf apache-tomcat.tar.gz apache-tomcat-9.0.17</code></p>
</blockquote>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>压缩成 zip 后缀文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip –r filename.zip directory_name</span><br></pre></td></tr></table></figure>

<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>远程连接，看例子 <code>ssh root@119.21.241.41</code></p>
<blockquote>
<p><code>ssh -p 10229 root@119.21.241.41</code>  </p>
</blockquote>
<p>有几个相关的小点需要注意</p>
<ul>
<li><code>cat /etc/hostname</code> 查看主机名，可用vim修改</li>
<li><code>cat /etc/ssh/sshd_config</code> 查看 <strong>ssh</strong> 服务的配置，可用vim修改</li>
<li><code>netstat -anlp | grep sshd</code> 查看 <strong>ssh</strong> 服务占用的端口号</li>
</ul>
<h1 id="系统进程服务相关"><a href="#系统进程服务相关" class="headerlink" title="系统进程服务相关"></a>系统进程服务相关</h1><h2 id="查看当前系统进程"><a href="#查看当前系统进程" class="headerlink" title="查看当前系统进程"></a>查看当前系统进程</h2><p><strong>ps -ef | grep</strong> , 比如</p>
<blockquote>
<p><code>ps -ef | grep docker</code> 查看名为 <strong>docker</strong> 的进程</p>
</blockquote>
<h2 id="kill-某进程"><a href="#kill-某进程" class="headerlink" title="kill 某进程"></a>kill 某进程</h2><p><strong>kill -9</strong>，比如</p>
<blockquote>
<p><code>kill -9 27643</code> 强制杀死id为27643的进程</p>
</blockquote>
<h2 id="系统服务相关"><a href="#系统服务相关" class="headerlink" title="系统服务相关"></a>系统服务相关</h2><h3 id="查看系统服务"><a href="#查看系统服务" class="headerlink" title="查看系统服务"></a>查看系统服务</h3><p><strong>service 服务名 status</strong>, 比如 </p>
<blockquote>
<p><code>service sshd status</code> :查询 ssh 服务的运行状态</p>
</blockquote>
<h3 id="关闭某个服务"><a href="#关闭某个服务" class="headerlink" title="关闭某个服务"></a>关闭某个服务</h3><p><strong>service 服务名 stop</strong> </p>
<h3 id="重启某个服务"><a href="#重启某个服务" class="headerlink" title="重启某个服务"></a>重启某个服务</h3><p><strong>service 服务名 restart</strong></p>
]]></content>
      <tags>
        <tag>Linus</tag>
      </tags>
  </entry>
  <entry>
    <title>angular基础</title>
    <url>/2016/12/26/angular%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>接触angular已经近半年了，一直在用别人的指令改改，遇到了很多自己解决不了的坑，其实自己对angular的各部分了解并不多，现在回头来弄清其中的用法原理，打好自己的基础。</p>
<span id="more"></span>

<blockquote>
<p>准备从如下几个部分展开，每个部分放出参考文章链接以及代码仓库地址</p>
</blockquote>
<h1 id="tisps"><a href="#tisps" class="headerlink" title="tisps"></a>tisps</h1><p>1.module.run()方法在注射器加载完所有模块是执行一次</p>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><blockquote>
<p><a href="https://github.com/snowyYU/angularPractice">git</a></p>
</blockquote>
<blockquote>
<p>先记几个核心问题<br>1.指令的运行原理：comile与link(操作元素，添加CSS样式，绑定事件)<br>2.指令与控制器之间的交互<br>3.指令间的交互<br>4.scope的类型与独立scope<br>5.scope的绑定策略<br>6.angularjs内置指令(63)<br>7.Expander,Accordion<br>8.directive思想的起源和原理概述</p>
</blockquote>
<h2 id="指令有三个阶段"><a href="#指令有三个阶段" class="headerlink" title="指令有三个阶段"></a>指令有三个阶段</h2><blockquote>
<p>1.<code>加载阶段</code>&gt;&gt;&gt;2.<code>编译阶段</code>&gt;&gt;&gt;3.<code>链接阶段</code></p>
</blockquote>
<p>1.加载angular.js，找到ng-app指令，确定应用的边界</p>
<p>2.遍历DOM，找到所有指令；根据指令代码中的temlate,replace,transclue转换DOM结构；如果存在compile函数则调用；</p>
<p>3.对每一条指令运行link函数；link函数一般用来操作DOM，绑定事件监听器；</p>
<blockquote>
<p>compile函数用来对模板自身进行转换，而link函数负责在模型和视图之间进行动态关联；<br>作用域在链接阶段才会被绑定到编译后的link函数上；<br>compile函数仅仅在编译阶段运行一次，而对于指令的每个实例，link函数都会执行一次；<br>compile可以返回preLink和postLink函数，而link函数只会返回postLink函数；<br>如果需要修改DOM结构，应该在postLink中来做这件事，而如果在preLink中做这件事会导致错误；<br>大多数时候我们只要写link函数即可  </p>
</blockquote>
<h2 id="配置含义"><a href="#配置含义" class="headerlink" title="配置含义"></a>配置含义</h2><p>练习指令时偶尔发现安装的sublime插件自动补全，如下格式</p>
<pre><code>app.directive(&#39;&#39;, [&#39;&#39;, function()&#123;
// Runs during compile
return &#123;
    // name: &#39;&#39;,
    // priority: 1,
    // terminal: true,
    // scope: &#123;&#125;, // &#123;&#125; = isolate, true = child, false/undefined = no change
    // controller: function($scope, $element, $attrs, $transclude) &#123;&#125;,
    // require: &#39;ngModel&#39;, // Array = multiple requires, ? = optional, ^ = check parent elements
    // restrict: &#39;A&#39;, // E = Element, A = Attribute, C = Class, M = Comment
    // template: &#39;&#39;,
    // templateUrl: &#39;&#39;,
    // replace: true,
    // transclude: true,
    // compile: function(tElement, tAttrs, function transclude(function(scope, cloneLinkingFn)&#123; return function linking(scope, elm, attrs)&#123;&#125;&#125;)),
    link: function($scope, iElm, iAttrs, controller) &#123;
        
    &#125;
&#125;;
&#125;]);
</code></pre>
<p>对各个属性都有注释，做个参考吧</p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>replace 属性为 true 时，指令标签会被 templete中的内容替换掉，如</p>
<pre><code>var appModule = angular.module(&#39;app&#39;, []);
appModule.directive(&#39;hello&#39;, function() &#123;
return &#123;
    restrict: &#39;E&#39;,
    template: &#39;&lt;div&gt;Hi there&lt;/div&gt;&#39;,
    replace: true
&#125;;
&#125;);
</code></pre>
<p>打开浏览器调试工具只能看到<code>&lt;div&gt;Hi there&lt;/div&gt;</code></p>
<h3 id="transclude"><a href="#transclude" class="headerlink" title="transclude"></a>transclude</h3><p>值为true时保留指令包裹的内容</p>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>作用域，用来隔离指令与所在控制器间的作用域、隔离指令与指令间的作用域</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.学习例子参考大漠老师的<a href="http://damoqiongqiu.iteye.com/blog/1917971">5个实例详解指令机制</a></p>
<p>2.<a href="https://segmentfault.com/a/1190000004586636">angular指令的transclude选项以及ng-transclude指令</a></p>
<p>3.<a href="http://www.tuicool.com/articles/aAveEj">directive和controller通信</a></p>
<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><h1 id="angular核心"><a href="#angular核心" class="headerlink" title="angular核心"></a>angular核心</h1><h1 id="angular原理"><a href="#angular原理" class="headerlink" title="angular原理"></a>angular原理</h1>]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>start</tag>
      </tags>
  </entry>
  <entry>
    <title>angular杂谈</title>
    <url>/2016/12/26/angular%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>这里来记一些angular相关的东西</p>
<span id="more"></span>
<h1 id="驼峰命名"><a href="#驼峰命名" class="headerlink" title="驼峰命名"></a>驼峰命名</h1><p>直接上例子，指令中的命名</p>
<pre><code> var appModule=angular.module(&#39;app&#39;,[]);    
appModule.directive(&#39;helloWorld&#39;,function()&#123;
    return&#123;
        restrict:&#39;e&#39;,
        template:&#39;&lt;div&gt;hello world~&lt;/div&gt;&#39;,
        replace:true
    &#125;;
    &#125;)
</code></pre>
<p>html中</p>
<pre><code>&lt;hello-world&gt;&lt;/hello-world&gt;
</code></pre>
<h1 id="service和factory"><a href="#service和factory" class="headerlink" title="service和factory"></a>service和factory</h1><blockquote>
<p>参考地址<br>1.<a href="https://segmentfault.com/a/1190000003096933">segmentfault</a><br>2.<a href="http://stackoverflow.com/questions/15666048/angularjs-service-vs-provider-vs-factory?rq=1">AngularJS: Service vs provider vs factory</a><br>3.<a href="https://docs.angularjs.org/api/auto/service/$provide">官网api,$provider</a><br>4.<a href="http://stackoverflow.com/questions/25667321/what-is-the-type-friendly-injection">What is the type friendly injection?</a></p>
</blockquote>
<p>-service和factory本质都是provider的shortcut<br>-‘provider’是唯一一种可以创建用来注入到config()函数的服务的方式。想在你的服务启动之前，进行一些模块化的配置的话，就使用provider</p>
<p>在官方文档中,auto模块中的服务有且仅有$injuector和$provider<br>对auto模块解释为 自动获取并添加到每个注入器的隐含模块</p>
]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio Code 相关</title>
    <url>/2019/12/13/Visual-Studio-Code-%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>之前使用 setting sync 同步过别人 git gist 上的 vsCode 配置，接触了一些很好用的功能，不过同时也有大量的拓展和相关配置一并被下载下来了，然后就遇到了些问题，现在准备重新安装vscode</p>
<span id="more"></span>

<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><h1 id="之前遇到的问题"><a href="#之前遇到的问题" class="headerlink" title="之前遇到的问题"></a>之前遇到的问题</h1><ol>
<li>debug 配置文件 lanch.js 无法触发 智能输入</li>
</ol>
<h1 id="拓展部分"><a href="#拓展部分" class="headerlink" title="拓展部分"></a>拓展部分</h1><ol>
<li><strong>YAML</strong> 支持</li>
<li><strong>Auto Close Tag</strong> 自动添加 html/xml 闭合标签</li>
<li><strong>Auto Rename Tag</strong> 修改标签名的辅助插件</li>
<li><strong>Auto import</strong> 自动 import</li>
<li><strong>Babel JavaScript</strong> 支持 react jsx， es201* flow GraphQL 的语法高亮</li>
<li><strong>Bash Debug</strong>  debug下的lanch.js 配置支持</li>
<li><strong>Better Comments</strong> 注释用的，让注释更加可视化，五颜六色的</li>
<li><strong>Branket Pair colorizer</strong>  标签，括号，范围提示</li>
<li><strong>Community Material Theme</strong> 一个主题，注意相关配置</li>
<li><strong>Dart dart</strong> 语言支持</li>
<li><strong>Debugger for Chrome</strong> 基于 chrome 的调试工具</li>
<li><strong>Django</strong></li>
<li><strong>Docker</strong></li>
<li><strong>DotENV</strong> 环境配置文件(.env,.env.development……结尾)语法高亮</li>
<li><strong>EJS language support</strong></li>
<li><strong>ES6 Mocha Snippets</strong></li>
<li><strong>ES7 React/Redux/GraphQL/React-Native snippets</strong></li>
<li><strong>ESLint</strong></li>
<li><strong>Formatting Toggle</strong></li>
<li><strong>GitLens</strong> — Git supercharged git 拓展</li>
<li><strong>HTML CSS Support</strong> html css 拓展</li>
<li><strong>Ignore files</strong> .gitignore 等文件的语法高亮</li>
<li><strong>Import Cost</strong> 自动计算import 文件的大小</li>
<li><strong>IntelliSense for CSS class names in HTML</strong> 自动检测引入的类名，智能提示补全</li>
<li><strong>JavaScript (ES6) code snippets</strong> es6代码片段</li>
<li><strong>JavaScript Booster</strong></li>
<li><strong>Jest Snippets</strong></li>
<li><strong>Jinja</strong></li>
<li><strong>JS Refactor</strong></li>
<li><strong>json2ts</strong> 将json 转化为 ts interface 文件</li>
<li><strong>LeetCode</strong> 算法题目</li>
<li><strong>Less IntelliSense</strong> less 的智能辅助</li>
<li><strong>Live Sass Compiler</strong> 一个即时sass 编译插件</li>
</ol>
<p>主要是对安装的拓展做个简介，方便自己后续的查找</p>
<h1 id="同步-gist"><a href="#同步-gist" class="headerlink" title="同步 gist"></a>同步 gist</h1>]]></content>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>dataTables内嵌二级表格的实现</title>
    <url>/2017/05/23/dataTables%E5%86%85%E5%B5%8C%E4%BA%8C%E7%BA%A7%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>之前在写angular时有用过ui-grid写过内嵌展开二级表格，怎么说呢，ui-grid很强大，功能挺多的，好像也是angular团队开发的，例子足，文档好(对那些英文阅读能力比较好的人来说)，不过他的有些功能不稳定，其中就包括表格中内嵌表格的实现<a href="http://ui-grid.info/docs/#/tutorial/216_expandable_grid">Expandable grid</a>。</p>
<p>之后在写别的项目时也遇到了相同的需求，这次准备使用datatables，在此记录下过程。</p>
<p>直接上代码:</p>
<h1 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h1><pre><code>//这个div用来存放查询条件
&lt;div&gt;
    &lt;div class=&quot;float-left m-b-md&quot;&gt;&lt;label&gt;账户名:&lt;/label&gt;&lt;input id=&quot;accountName&quot; type=&quot;text&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;float-left m-b-md&quot;&gt;&lt;label&gt;银行账号:&lt;/label&gt;&lt;input id=&quot;bankAccount&quot; type=&quot;text&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;float-left m-b-md&quot;&gt;&lt;label&gt;账户ID:&lt;/label&gt;&lt;input id=&quot;accountId&quot; type=&quot;text&quot;&gt;&lt;/div&gt;
    
    &lt;button id=&quot;searchBtn&quot; class=&quot;m-b-md&quot;&gt;查询&lt;/button&gt;
&lt;/div&gt;
//以下是table的主体
&lt;table id=&quot;example&quot; class=&quot;display&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th&gt;账户ID&lt;/th&gt;
            &lt;th&gt;账户名&lt;/th&gt;
            &lt;th&gt;账户状态&lt;/th&gt;
            &lt;th&gt;账户类型&lt;/th&gt;
            &lt;th&gt;账户余额&lt;/th&gt;
            &lt;th&gt;银行账号&lt;/th&gt;
            &lt;th&gt;冻结金额&lt;/th&gt;
            &lt;th&gt;在途金额&lt;/th&gt;
            &lt;th&gt;最后交易时间&lt;/th&gt;
            
            
        &lt;/tr&gt;
    &lt;/thead&gt;
&lt;/table&gt;
</code></pre>
<p>html部分分为搜索部分和table主体部分，挺简单的没啥说的</p>
<h1 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h1><pre><code>    //1.初始化部分
    //1.1禁用表格自带的搜索和排序
    $.extend($.fn.dataTable.defaults, &#123;
        searching: false,
        ordering: false
    &#125;);
    //1.2初始化表格主体
    var table = $(&#39;#example&#39;).DataTable(&#123;
    //配置相应部分的中文显示(废话，不然就显示英文了)
        &quot;language&quot;: &#123;
            &quot;lengthMenu&quot;: &quot;每页 _MENU_ 条记录&quot;,
            &quot;zeroRecords&quot;: &quot;没有找到记录&quot;,
            &quot;info&quot;: &quot;第 _PAGE_ 页 ( 总共 _PAGES_ 页 )&quot;,
            &quot;infoEmpty&quot;: &quot;无记录&quot;,
            &quot;infoFiltered&quot;: &quot;(从 _MAX_ 条记录过滤)&quot;,
            &quot;paginate&quot;: &#123;
                &quot;first&quot;: &quot;First&quot;,
                &quot;last&quot;: &quot;Last&quot;,
                &quot;next&quot;: &quot;后一页&quot;,
                &quot;previous&quot;: &quot;上一页&quot;
            &#125;,
        &#125;,
    
        &quot;pageLength&quot;: 10,           //默认每页条数
        &quot;lengthChange&quot;: false,      //禁掉表格自带的选择每页条数的下拉框
        &quot;processing&quot;: true,         //是否显示进度遮罩
        &quot;serverSide&quot;: true,         //开启服务端传输数据
        &quot;ajax&quot;: &#123;                   //ajax
            url: &quot;$&#123;ctx&#125;/client/account/accountListData&quot;,
            type: &quot;POST&quot;,
            data: function(d) &#123;
                //获取查询条件的值
                var accountName  = $(&quot;#accountName&quot;).val();
                var bankAccount  = $(&quot;#bankAccount&quot;).val();
                var accountId  = $(&quot;#accountId&quot;).val();
                //添加额外的参数传给服务器  
                 d.accountName = accountName;
                 d.bankAccountNo = bankAccount;
                 d.accountId = accountId;
            &#125;,
            
        &#125;,
        //这里虽然没用到，但这个属性很有用，可以初始datatable的data(还是去看看官网吧)，因为插件对返回值的格式要求严格
        /* &quot;dataSrc&quot;: function(json)&#123;
               
               return json.data[0].body.records;
            &#125;, */
        //配置各列
        &quot;columns&quot;: [&#123;
            className: &#39;details-control&#39;,   //就是给这列添加的类名
            orderable: false,               //禁用掉这列的排序功能
            data: null,                  //data为空，因为这列只有展开icon
            defaultContent: &#39;&#39;          //没数据的话为空
            &#125;,&#123;
            data:&#39;accountId&#39;
                /* &quot;targets&quot;: 0,
                &quot;data&quot;: &quot;body&quot;,
                &quot;render&quot;: function ( data, type, full, meta ) &#123;
                  return data.records.memberId;
                &#125; */
            &#125;,&#123;
            data: &#39;accountName&#39;
            &#125;,&#123;
            data: &#39;accountStatusdic&#39;
            &#125;,&#123;
            data: &#39;accounTypedic&#39;
            &#125;,&#123;
            data: &#39;availableBalance&#39;
            &#125;,&#123;
            data: &#39;bankAccount&#39;
            &#125;,&#123;
            data: &#39;freezeBalance&#39;
            &#125;,&#123;
            data: &#39;undeterminedBalance&#39;
            &#125;,/* &#123;
            data: &#39;memberId&#39;,
            &#125;,&#123;
            data: &#39;memberStatusDic&#39;,  
            &#125;, */&#123;
             data: &#39;lastTranTime&#39;
            &#125;
            ],
        &quot;columnDefs&quot;: [
            &#123;
                targets: [5, 7, 8 ],  //这个用于对列的批量处理，里面为需要处理的列的下标
                //render很有用，这里主要是过滤用，好像在columns中也可以写render
                render: function(data,type,row,meta)&#123;
                    return (&quot;￥&quot;+data.toFixed(2));
                &#125;
            &#125;,
            
         ] 
    &#125;);
    //点击查询，触发表格的渲染
    $(&quot;#searchBtn&quot;).click(function() &#123;
        table.ajax.reload();
    &#125;);
    //二级table的模板
    function format(table_id) &#123;
        return &#39;&lt;table class=&quot;table table-striped&quot; id=&quot;opiniondt_&#39; + table_id + &#39;&quot;&gt;&#39; +
        &#39;&lt;thead&gt;&#39;+
        &#39;&lt;tr&gt;&#39;+
        &#39;&lt;th&gt;账户ID&lt;/th&gt;&lt;th&gt;账户名&lt;/th&gt;&lt;th&gt;账户状态&lt;/th&gt;&#39;+
        &#39;&lt;th&gt;账户类型&lt;/th&gt;&lt;th&gt;可用余额&lt;/th&gt;&lt;th&gt;冻结金额 &lt;/th&gt;&#39;+
        &#39;&lt;th&gt;最后交易时间&lt;/th&gt;&lt;th&gt;锁定金额&lt;/th&gt;&lt;th&gt;在途金额&lt;/th&gt;&#39;+
        &#39;&lt;/tr&gt;&#39;+
        &#39;&lt;/thead&gt;&#39; +
        &#39;&lt;tr&gt;&#39; +
        &#39;&lt;td&gt;Full name:&lt;/td&gt;&#39; +
        &#39;&lt;td&gt;Extension number:&lt;/td&gt;&#39; +
        &#39;&lt;td&gt;Extra info:&lt;/td&gt;&#39; +
        &#39;&lt;/tr&gt;&#39; +
        &#39;&lt;tr&gt;&#39; +
        &#39;&lt;td&gt;Full name:&lt;/td&gt;&#39; +
        &#39;&lt;td&gt;Extension number:&lt;/td&gt;&#39; +
        &#39;&lt;td&gt;Extra info:&lt;/td&gt;&#39; +
        &#39;&lt;/tr&gt;&#39; +
        &#39;&lt;/table&gt;&#39;;
    &#125;
    //先初始化一个变量，用于动态给展开的二级table赋值
    var iTableCounter = 1;
    var oInnerTable;
    //展开icon的点击事件
    $(&#39;#example tbody&#39;).on(&#39;click&#39;, &#39;td.details-control&#39;, function() &#123;
        //获得最近的tr老爸
        var tr = $(this).closest(&#39;tr&#39;);
        //遍历老铁们
        var td = $(this).siblings(&quot;td&quot;);
        //获取第一个老铁的内容
        var acId=td[0].innerHTML;
        
        //把选择的这一行变成datatable的行，这样就可以使用一些方法了
        //dataTables默认给所有的行设置了他们的子显示区
        //可通过row().child.show()和row().child.hide()显示隐藏
        var row = table.row(tr);
        
        var data;
        if (row.child.isShown()) &#123;
            //  This row is already open - close it
            row.child.hide();
            //这个shown是为了控制展开icon和收缩icon的切换显示
            tr.removeClass(&#39;shown&#39;);
        &#125; else &#123;
            //ajax开始传参给后台
              $.ajax(&#123;
                url:&quot;$&#123;ctx&#125;/client/account/getSlaveAccount&quot;,
                type:&quot;POST&quot;,
                data:&#123;accountId:acId&#125;,
            &#125;).done(function(res)&#123;
                data = JSON.parse(res);
                //这里是请求后台字典接口，进行过滤数据，记住设置为同步请求
                data.slaveAccounts.forEach(function(e)&#123;
                    (function()&#123;
                    $.ajax(&#123;
                        url:&quot;$&#123;ctx&#125;/client/dict/getDicValue&quot;,
                        type:&quot;post&quot;,
                        async:false,
                        data:&#123;
                            type:&quot;accountType&quot;,
                            value:e.accountType,
                            defaultValue:&quot;&quot;
                        &#125;
                    &#125;).done(function(res1)&#123;
                        e.accountType=res1;
                    &#125;);
                &#125;());
                    //处理accountStatus
                    (function()&#123;
                    $.ajax(&#123;
                        url:&quot;$&#123;ctx&#125;/client/dict/getDicValue&quot;,
                        type:&quot;post&quot;,
                        async:false,
                        data:&#123;
                            type:&quot;accountStatus&quot;,
                            value:e.accountStatus,
                            defaultValue:&quot;&quot;
                        &#125;
                    &#125;).done(function(res2)&#123;
                        e.accountStatus=res2;
                    &#125;);
                    &#125;());
                &#125;)
                var lastData=data.slaveAccounts;
                // Open this row
                //child()内接收二级table的模板
                row.child(format(iTableCounter)).show();
                //显示出收缩icon
                tr.addClass(&#39;shown&#39;);
                // try datatable stuff
                //为所有的二级列表配置
                oInnerTable = $(&#39;#opiniondt_&#39; + iTableCounter).dataTable(&#123;
                    data: lastData,
                    autoWidth: true,
                    deferRender: true,
                    info: false,
                    lengthChange: false,
                    ordering: false,
                    paging: false,
                    scrollX: false,
                    scrollY: false,
                    searching: false,
                    columns: [&#123;
                        data: &#39;accountId&#39;
                    &#125;, &#123;
                        data: &#39;accountName&#39;
                    &#125;, &#123;
                        data: &#39;accountStatus&#39;
                    &#125;, &#123;
                        data: &#39;accountType&#39;
                    &#125;, &#123;
                        data: &#39;availableBalance&#39;
                    &#125;, &#123;
                        data: &#39;freezeBalance&#39;
                    &#125;, &#123;
                        data: &#39;lastTranTime&#39;
                    &#125;, &#123;
                        data: &#39;lockBalance&#39;
                    &#125;, &#123;
                        data: &#39;undeterminedBalance&#39;
                    &#125;],
                    columnDefs: [&#123;
                        targets: [4,5, 7, 8 ],
                        render: function(data,type,row,meta)&#123;
                                    return (&quot;￥&quot;+data.toFixed(2));
                                &#125;
                    &#125;] 
                &#125;);
                //+1后下一个展开的二级table的id加1
                iTableCounter = iTableCounter + 1;
            &#125;)  
        &#125;
    &#125;)
</code></pre>
<p>嗯，想说的过程全变成注释了，就酱吧。</p>
<h1 id="别的东西"><a href="#别的东西" class="headerlink" title="别的东西"></a>别的东西</h1><h2 id="从别处访问获得的json数据"><a href="#从别处访问获得的json数据" class="headerlink" title="从别处访问获得的json数据"></a>从别处访问获得的json数据</h2><p>2017.06.09，之后遇到了这个问题，去查了下文档，在datatable配置内可通过<code>this.api().ajax.json()</code>访问获得的json数据</p>
<blockquote>
<p>其实this指向的就是table</p>
</blockquote>
<h2 id="操作行数据"><a href="#操作行数据" class="headerlink" title="操作行数据"></a>操作行数据</h2><p>一般是写在监听事件的处理函数中的，如下，获取触发点击事件哪一行的数据<br>    table.row( this ).data()</p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>angular相关问题</title>
    <url>/2017/05/10/angular%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>整理一些angular相关的问题，多了再整理</p>
<h1 id="angular-的数据绑定采用什么机制"><a href="#angular-的数据绑定采用什么机制" class="headerlink" title="angular 的数据绑定采用什么机制"></a>angular 的数据绑定采用什么机制</h1><p>脏检查机制。</p>
<p>双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。</p>
<p>原理就是，Angular 在 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发，遍历所有的 $watch，最后更新 dom。</p>
<p>举个栗子</p>
<pre><code>&lt;button ng-click=&quot;val=val+1&quot;&gt;increase 1&lt;/button&gt;
</code></pre>
<p>click 时会产生一次更新的操作（至少触发两次 $digest 循环）</p>
<p>按下按钮<br>浏览器接收到一个事件，进入到 angular context<br>$digest 循环开始执行，查询每个 $watch 是否变化<br>由于监视 $scope.val 的 $watch 报告了变化，因此强制再执行一次 $digest 循环<br>新的 $digest 循环未检测到变化<br>浏览器拿回控制器，更新 $scope.val 新值对应的 dom<br>$digest 循环的上限是 10 次（超过 10次后抛出一个异常，防止无限循环）。</p>
<blockquote>
<p>自己感觉吧，绑定在$scope上的变量都会被监听，有变化时会刷新整个$scope上的队列。</p>
</blockquote>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ol>
<li><a href="https://docs.angularjs.org/misc/faq">官网FAQ</a></li>
<li><a href="https://www.zhihu.com/question/36040694">知乎-如何衡量一个人的angular水平</a></li>
</ol>
]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title>docker入门</title>
    <url>/2020/06/29/docker%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>记录些安装，配置，和使用上的一些心得，方便日后查阅</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="在centOS上安装"><a href="#在centOS上安装" class="headerlink" title="在centOS上安装"></a>在centOS上安装</h2><p>mac 上安装的话直接有相应的安装包，很简单，现在主要说下服务端的，流程大致可以参考官方 <a href="https://docs.docker.com/engine/install/centos/">docker install</a>，不过要注意，我在centos8 上执行到 <code>sudo yum install docker-ce docker-ce-cli containerd.io</code> 命令报错（应该是containerd.io版本问题）。</p>
<p>此时需要先执行 </p>
<p><code>dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm</code> </p>
<p>先安装 containerd.io。</p>
<p>再执行 <code>sudo yum install docker-ce docker-ce-cli</code> ,<code>sudo systemctl start docker</code> 安装剩下两个</p>
<h2 id="配置国内镜像"><a href="#配置国内镜像" class="headerlink" title="配置国内镜像"></a>配置国内镜像</h2><p>编辑 <code>sudo vi /etc/docker/daemon.json</code><br>加入如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://1nj0zren.mirror.aliyuncs.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://f1361db2.m.daocloud.io&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>好像 <code>&quot;https://registry.docker-cn.com&quot;</code> 失效了</p>
</blockquote>
<h1 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h1><p>参考官方安装文档 <a href="https://docs.docker.com/compose/install/">compose install</a></p>
<ol>
<li>下载安装  </li>
</ol>
<p><code>sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code><br>2. 给权限 <code>sudo chmod +x /usr/local/bin/docker-compose</code><br>3. 测试是否安装成功 <code>docker-compose --version</code></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>eslint初涉</title>
    <url>/2017/05/05/eslint%E5%88%9D%E6%B6%89/</url>
    <content><![CDATA[<p>便于养成良好的代码习惯和规范性，开始学习eslint,还有sublime相应的插件安装</p>
<span id="more"></span>

<h1 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h1><p>eslint 还是挺强大的，相较于jshint</p>
<blockquote>
<p>新版本配置文件 .eslint 被抛弃，建议使用 .eslint.js来进行配置，不过我分别尝试后发现第二种行不通，暂时还没找到问题，就都记下来</p>
</blockquote>
<h1 id="eslint-配置"><a href="#eslint-配置" class="headerlink" title=".eslint 配置"></a>.eslint 配置</h1><h2 id="安装nodejs部分"><a href="#安装nodejs部分" class="headerlink" title="安装nodejs部分"></a>安装nodejs部分</h2><pre><code>npm install eslint -g
npm install babel-eslint -g
</code></pre>
<h2 id="在sublime-安装-eslint-插件"><a href="#在sublime-安装-eslint-插件" class="headerlink" title="在sublime 安装 eslint 插件"></a>在sublime 安装 eslint 插件</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>SublimeLinter</li>
<li>SublimeLinter-contrib-eslint</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在项目根目录编写配置文件</p>
<p>.eslintrc</p>
<pre><code>&#123;
&quot;env&quot;: &#123;
    &quot;browser&quot;: true,
    &quot;node&quot;: true,
    &quot;es6&quot;: true
&#125;,
&quot;parser&quot;: &quot;babel-eslint&quot;,
&quot;ecmaFeatures&quot;: &#123;
   &quot;jsx&quot;: true
&#125;,
&quot;rules&quot;: &#123;
    &quot;semi&quot;: [2, &quot;always&quot;],
    &quot;quotes&quot;: [2, &quot;single&quot;]
&#125;
&#125;
</code></pre>
<p>sublime 编辑器内Prefernces &gt; Pakage Settings &gt; SublimeLinter &gt; Settings-User<br>debug设置为true</p>
<p>it works</p>
<p><img src="http://i.imgur.com/gXpuFcw.png" alt="效果"></p>
<h1 id="eslint-js"><a href="#eslint-js" class="headerlink" title=".eslint.js"></a>.eslint.js</h1><p>看了些文档后好像可以通过运行如下命令在控制台输出错误信息</p>
<pre><code>$ eslint yourfile.js
</code></pre>
<p>也就是说不需要sublime了，喔</p>
<h2 id="node-js部分的相关安装"><a href="#node-js部分的相关安装" class="headerlink" title="node.js部分的相关安装"></a>node.js部分的相关安装</h2><p>局部安装</p>
<p>不说了，看参考链接2</p>
<p>全局安装</p>
<pre><code>$ npm i -g eslint
</code></pre>
<blockquote>
<p>一直分不清 <code>$ npm i -g eslint</code>和<code>$ npm i eslint -g</code>的区别</p>
</blockquote>
<p>初始化</p>
<pre><code>$ eslint --init
</code></pre>
<p>建议命令行配置如下</p>
<ul>
<li>Use a popular style guide</li>
<li>Standard</li>
<li>JavaScript</li>
</ul>
<blockquote>
<p>可以看看参考链接3</p>
</blockquote>
<blockquote>
<p>注意，这个需要package.json的配置了，全局使用的话要同样全局安装使用到的插件，比如如下配置的话就要全局安装plugins里的了</p>
</blockquote>
<p><img src="http://i.imgur.com/4l6XQ0o.png" alt="plugins"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol>
<li>.eslint的使用感觉更方便啊，不需要配置package.json，不需安装相应的node_module。不过明显感觉.eslint.js更智能，有脚手架的感觉</li>
<li>优先级方面</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://blog.csdn.net/binjly/article/details/49926001">.eslint</a></li>
<li><a href="http://eslint.org/docs/user-guide/getting-started">官方起步文档,不过没有sublime的配置部分</a></li>
<li><a href="http://www.jianshu.com/p/e826e13c67ec">参考链接3</a></li>
</ol>
]]></content>
      <categories>
        <category>eslint</category>
      </categories>
      <tags>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中this</title>
    <url>/2017/05/08/javascript%E4%B8%ADthis/</url>
    <content><![CDATA[<p>javascript中的this接触很多，但一直是模模糊糊的，在这里整理下</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p>与其他语言相比，函数的 this 关键字在JavaScript中的行为略有不同。它在严格模式和非严格模式之间也有一些区别。</p>
<p>读了廖雪峰老师的文章感觉文中所说的调用对象就是指执行环境，不知道可不可以这样理解</p>
<p>当一个函数被调用时，会创建一个 __执行环境(execution context)__及相应的作用域链，自动获取两个特殊变量：this和arguments，然后使用arguments和其他命名参数的值来初始化函数的 **活动对象(activation object)**，</p>
<p><code>(function()&#123;&#125;())</code>立即执行函数</p>
<p>构造函数模式创建对象时，会经历以下4个步骤</p>
<ol>
<li>创建一个新对象</li>
<li>见构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li>
<li>执行构造函数中的代码（为这个对象添加属性）</li>
<li>返回新对象</li>
</ol>
<h1 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h1><p>this总是指向调用函数的那个对象,在运行时基于函数的执行环境绑定的</p>
<h2 id="纯函数调用"><a href="#纯函数调用" class="headerlink" title="纯函数调用"></a>纯函数调用</h2><p>属于全局调用，this代表全局对象Global</p>
<pre><code>function foo()&#123;
    console.log(this);
&#125;;
foo(); //Window
</code></pre>
<h2 id="作为对象方法的调用"><a href="#作为对象方法的调用" class="headerlink" title="作为对象方法的调用"></a>作为对象方法的调用</h2><p>this指向调用的函数</p>
<h2 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h2><p>this 指向当前实例对象</p>
<h2 id="apply-amp-amp-call"><a href="#apply-amp-amp-call" class="headerlink" title="apply &amp;&amp; call"></a>apply &amp;&amp; call</h2><p>apply()和call()作为函数对象的方法，可以改变函数的执行环境(调用对象)<br>它们的第一个参数是个对象，即作为函数内的this。</p>
<pre><code>function foo()&#123;
    console.log(this);
&#125;
foo.call(1);  //1
foo.call(&#39;a&#39;);  //a
foo.call(true);  //true
foo.call(&#123;type:object&#125;);  //[object Object]
</code></pre>
<p>如上，他们的参数作为函数内的this输出</p>
<p>需要注意的是，传null或undefined时，将是JS执行环境的全局变量。浏览器中是window,其他环境，如node则是global。</p>
<pre><code>fun.call(null);  //window or global
fun.call(undefined);  //window or global
</code></pre>
<p>apply()和call()唯一的区别是参数不一样，apply的第二个参数必须传入数组。<br>如 </p>
<pre><code>func1.call(this, arg1, arg2);
func1.apply(this, [arg1, arg2]);
</code></pre>
<h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h3><p>js中函数的参数不固定，当参数是明确知道数量时，用 call，而不确定的时候，用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个 __类数组__来便利所有的参数。</p>
<h3 id="小小结"><a href="#小小结" class="headerlink" title="小小结"></a>小小结</h3><ol>
<li>apply() 的第一个参数是对象，第二个参数是数组，作为参数列表。</li>
<li></li>
</ol>
<h1 id="从ECMAScript规范谈this"><a href="#从ECMAScript规范谈this" class="headerlink" title="从ECMAScript规范谈this"></a>从ECMAScript规范谈this</h1><p>上面说的this的指向很偏应用的，倒是像经验上的总结。具体还是要看规范的，这部分打算之后再好好写写</p>
<blockquote>
<p>参考:<a href="https://github.com/mqyqingfeng/Blog/issues/7">JavaScript深入之从ECMAScript规范解读this</a></p>
</blockquote>
<h1 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h1><blockquote>
<p><a href="http://www.cnblogs.com/snandy/archive/2012/03/01/2373243.html">call和apply</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>git踩坑记</title>
    <url>/2017/04/19/git%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<p>总是容易忘记 git 的一些命令和用法，在此记下我重复 google 的，哈哈，比较无序，足够多时再分类。</p>
<span id="more"></span>

<h1 id="credentials-helper"><a href="#credentials-helper" class="headerlink" title="credentials helper"></a>credentials helper</h1><blockquote>
<p><a href="https://www.shellhacks.com/git-config-username-password-store-credentials/">Git – Config Username &amp; Password – Store Credentials</a></p>
</blockquote>
<h1 id="将文件移除监听队列"><a href="#将文件移除监听队列" class="headerlink" title="将文件移除监听队列"></a>将文件移除监听队列</h1><p>git 中如果文件已被加入跟踪队列，后续添加相应的.gitignore 参数时其相应的改变仍会被监听，采用如下</p>
<pre><code>git rm --cached XX/xx.x
</code></pre>
<blockquote>
<p>附上链接<br><a href="https://segmentfault.com/q/1010000000430426">git 忽略已经被提交的文件</a> &gt;<a href="http://www.ifeegoo.com/git-code-management-dot-gitignore-file-has-no-effect-solution.html">.gitignore 文件无效的解决方法</a></p>
</blockquote>
<h1 id="常见的-git-删除"><a href="#常见的-git-删除" class="headerlink" title="常见的 git 删除"></a>常见的 git 删除</h1><pre><code>git rm XXX.xx
</code></pre>
<p>如果误删了可采用<code>git checkout</code></p>
<blockquote>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区修改还是删除，都可以使用此还原</p>
</blockquote>
<h1 id="新增远程仓库地址"><a href="#新增远程仓库地址" class="headerlink" title="新增远程仓库地址"></a>新增远程仓库地址</h1><pre><code>git add remote [&lt;options&gt;] &lt;name&gt; &lt;url&gt;
//例子
git add remote origin https://github.com/snowyYU/x.git
</code></pre>
<p>name 为远程主机的名字</p>
<h1 id="push，push，push"><a href="#push，push，push" class="headerlink" title="push，push，push"></a>push，push，push</h1><pre><code>git push -u origin master
</code></pre>
<p>这里只想说一下-u 参数，设置了这个之后，pull fetch push 啥的默认连接的为 origin master</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/20019419">知乎 git push 的 -u 参数具体适合含义</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --all</span><br></pre></td></tr></table></figure>

<p>上面命令表示，将所有本地分支都推送到 origin 主机。如果远程主机的版本比本地版本更新，推送时 Git 会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 <code>–-force </code>选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<p><code>git push </code>不会推送标签(tag)，除非使用 <code>-–tags</code> 选项</p>
<h1 id="打上标签-tag"><a href="#打上标签-tag" class="headerlink" title="打上标签 tag"></a>打上标签 tag</h1><p>主要有两种方法</p>
<ul>
<li><code>git tag tagName</code></li>
<li><code>git tag -a tagName -m &quot;remarks备注&quot;</code></li>
</ul>
<p>查看<code>tags</code></p>
<ul>
<li><code>git tag</code></li>
</ul>
<p>从 tag 处开一个分支</p>
<p><code>git branch &lt;new-branch&gt; &lt;tag-name&gt;</code> 进行版本的管理</p>
<blockquote>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE">详情参考</a></p>
</blockquote>
<h1 id="log-和-reflog-命令"><a href="#log-和-reflog-命令" class="headerlink" title="log 和 reflog 命令"></a>log 和 reflog 命令</h1><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>展示所有的 commit</p>
<h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><p>展示所有的操作记录，相较 git log ，reflog 命令可以展示 reset 和已删除 commit 的操作</p>
<h1 id="merge-报错"><a href="#merge-报错" class="headerlink" title="merge 报错"></a>merge 报错</h1><p>今天在 pull 时出现了一个问题，过程是这样的，我新建了远程仓库时顺带初始化了 readme,结果本地 pull 时报错，如下</p>
<pre><code>fatal: refusing to merge unrelated histories
</code></pre>
<p>就是它觉得我两个仓库没啥关联，然后我尝试 push，报错如下</p>
<pre><code>$ git push -u origin master
To https://github.com/snowyYU/center-solution.git
! [rejected]        master -&gt; master (non-fast-forward)
error: failed to push some refs to &#39;https://github.com/snowyYU/center-solution.git&#39;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: &#39;git pull ...&#39;) before pushing again.
hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.
</code></pre>
<p>说我本地仓库版本过时啦，叫我先 pull</p>
<p>没办法，只能强上了，加上参数</p>
<pre><code>git pull origin master --allow-unrelated-histories
</code></pre>
<p>之后会进入 vim 让我输入 commit message，</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories">stackoverflow</a> &gt;<a href="http://www.jianshu.com/p/eae20fcde419">vim 命令看这里</a></p>
</blockquote>
<h2 id="撤销合并"><a href="#撤销合并" class="headerlink" title="撤销合并"></a>撤销合并</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure>

<p>有时候拉代码，合并，结果整个文件到处是冲突，可以使用此命令撤销到合并前的状态</p>
<blockquote>
<p>一般这种情况常见于仓库和本地工作环境有一端代码格式化不同步</p>
</blockquote>
<h1 id="查看更改处"><a href="#查看更改处" class="headerlink" title="查看更改处"></a>查看更改处</h1><pre><code>git diff
</code></pre>
<p>上图:</p>
<p><img src="http://i.imgur.com/QJamb2Z.jpg" alt="gitDiff"></p>
<p>这样只会对比当前工作区和所在分支最新 commit 的改动处，需要对比远程分支，可以看 <a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></p>
<h1 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h1><p>如果还没有使用 <code>add</code> 命令加入到暂存区，可以</p>
<h2 id="单个文件"><a href="#单个文件" class="headerlink" title="单个文件"></a>单个文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --filename</span><br></pre></td></tr></table></figure>

<h2 id="所有文件"><a href="#所有文件" class="headerlink" title="所有文件"></a>所有文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure>

<h2 id="清除所有新增未加入暂存区的文件-文件夹"><a href="#清除所有新增未加入暂存区的文件-文件夹" class="headerlink" title="清除所有新增未加入暂存区的文件/文件夹"></a>清除所有新增未加入暂存区的文件/文件夹</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clean -xdf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：-x 会清除掉 .gitignore 文件中的忽略文件，比如常见的 node_modules 文件</p>
</blockquote>
<p>详情见 <a href="https://www.makeuseof.com/git-clean/">Here’s How to Clean Git and Remove Untracked Files</a></p>
<p>如果已经 <code>add</code> 之后，想要撤销</p>
<h2 id="单个文件-1"><a href="#单个文件-1" class="headerlink" title="单个文件"></a>单个文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD filename</span><br></pre></td></tr></table></figure>

<h2 id="所有文件-1"><a href="#所有文件-1" class="headerlink" title="所有文件"></a>所有文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure>

<p>如果已经 <code>commit</code> 了，想要撤销</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset commit_id  // 撤销后所有的更改会变成 add 之前的状态，git status 之后就是一片红红红</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个 id 是你想要回到的那个节点，可以通过 git log 查看，可以只选前 6 位<br>或者 通过 gitreflog 命令取得</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id //撤销之后，所做的已经commit的修改将会清除，仍在工作区/暂存区的代码也将会清除！</span><br></pre></td></tr></table></figure>

<h1 id="创建-切换分支-删除"><a href="#创建-切换分支-删除" class="headerlink" title="创建,切换分支 ,删除"></a>创建,切换分支 ,删除</h1><p>今天在看 webpack 官网的指南时候，发现各部分练习的代码挺不一样，又想起之前看 angularjs 时官网给出的 phonecat，他们项目各个构建步骤被创建成一个个 branch，感觉十分方便，所以我仿照试下</p>
<pre><code>git checkout -b XXX
</code></pre>
<p>这个命令相当于</p>
<pre><code>git branch XXX    //新建XXX分支
git checkout XXX  //切换到XXX分支
</code></pre>
<p>现在就切换到 XXX 分支了，可以在 gitbash 中看到，然后我直接</p>
<p>一般情况下直接 clone 的项目只有 master 分支，想要获取远程别的分支代码还需要在本地检出一个分支，然后建立映射，这两步可以使用一条命令完成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure>

<p>git push origin XXX</p>
<p>其实此时远程仓库中并没有 XXX 分支，执行此命令后，远程仓库会新建 XXX 分支，并 push 成功。</p>
<pre><code>git branch -D XXX
</code></pre>
<p>删除本地的 XXX 分支</p>
<pre><code>git push origin :XXX
</code></pre>
<p>删除远程的 XXX 分支</p>
<h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h1><p>自己尝试更新 folk 到自己 github 上仓库时查到的这个命令，先上个链接</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/7244321/how-do-i-update-a-github-forked-repository">How do I update a GitHub forked repository?</a></p>
</blockquote>
<p>第一个答案大意就是，</p>
<ol>
<li>从自己的 GitHub 上 clone 至本地工作目录</li>
<li>在本地添加 remote，即从哪 folk 来的(这里先叫 upstream)，</li>
<li>fetch upstream 上的所有分支</li>
<li>切换到本地的 master 分支</li>
<li>将 upstream 上需要同步的分支 rebase</li>
</ol>
<p>我觉得 rebase 和 merge 差不多，区别可能是 rebase 不会留下痕迹，merge 需要输入 message 啥的</p>
<blockquote>
<p><a href="http://blog.csdn.net/hudashi/article/details/7664631/">git rebase</a></p>
</blockquote>
<h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>哈哈，这个命令还挺好玩的，能把当前工作区的更改先搁置，最常见的应用就是突然要去到之前的某个版本打个包。</p>
<p>使用 <code>git stash pop</code> 取回搁置的更改，继续撸码</p>
<blockquote>
<p>如果更改中有 untrack 的文件，需要加上 <code>-u</code> 参数，即 <code>git stash -u</code> 才能一起 stash 起来</p>
</blockquote>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>针对更新自己 folk 的仓库，官方后来又给出了 web 版本的方案，上面的是需要本地仓库的，先上链接</p>
<blockquote>
<p><a href="https://github.com/KirstieJane/STEMMRoleModels/wiki/Syncing-your-fork-to-the-original-repository-via-the-browser">www</a></p>
</blockquote>
<p>大致就是自己从源向自己 folk 的仓库发起 pull request,然后合并</p>
<h1 id="遇到-ping-github-com-time-out-问题"><a href="#遇到-ping-github-com-time-out-问题" class="headerlink" title="遇到 ping github.com time out 问题"></a>遇到 ping github.com time out 问题</h1><blockquote>
<p>可以在网页中正常访问 github，唯独在终端中连接不了 github，也 ping 不通</p>
</blockquote>
<p>喵喵喵？查了半天网上说了一堆关于 proxy 代理的问题，结果我连到手机的热点就可以了，所以下次遇到时尝试切换网络环境</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://www.zhihu.com/question/53601264">如何在 git 中对比当前工作区和远程仓库的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript作用域</title>
    <url>/2017/05/10/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ol>
<li><strong>执行环境</strong>(execution context,有时也叫“环境”,“执行上下文”,“”,“”)</li>
<li><strong>变量对象</strong>(variable object)</li>
<li><strong>活动对象</strong>(activation object)</li>
</ol>
<h1 id="执行环境和作用域"><a href="#执行环境和作用域" class="headerlink" title="执行环境和作用域"></a>执行环境和作用域</h1><p><strong>执行环境</strong>很重要，执行环境定义了变量或函数有权访问的其他数据(难道指的就是初始化的作用域链？),决定论它们各自的行为。每个执行环境都有一个与之关联的 <strong>变量对象</strong>(包含了环境中定义的所有变量和函数)(难道执行环境只包含了一个标识符指针列表？)，虽然我们的代码无法访问这个对象，但解析器在数据处理时会在后台使用它</p>
<p>全局执行环境是最外围的执行环境，在Web浏览器中，全局执行环节被认为是window对象</p>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<blockquote>
<p>也就是说这个栈一直存在，和全局执行环境一样关闭网页时才被销毁</p>
</blockquote>
<p>当代码在一个环境中执行时，会创建变量对象的一个 <strong>作用域链</strong>(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数有序的访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，活动对象在开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含(外部)环境，而再下个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<blockquote>
<p>作用域链存放在哪</p>
</blockquote>
<p>以上大部分来自js高程这本书，下面开始图解</p>
<h1 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h1><h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><pre><code>//myScript.js 
&quot;use strict&quot;    
var a=1;
var b=2; 
</code></pre>
<p>如图，开始时，创建全局执行环境并被推入执行环境栈<br><img src="http://i.imgur.com/FcKggu2.png" alt="p1"></p>
<h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><pre><code>//myScript.js 
&quot;use strict&quot;    
var a=1;
var b=2; 
function foo()&#123;
    var c=3;
    var d=4;
    console.log(c+d);
&#125;
</code></pre>
<p>执行至<code>function foo()&#123;&#125;</code>也就是函数创建时，food的标识符(identifier)被加到当前(栗子中是全局变量对象)中,并且这个标识符引用了一个函数对象，函数对象中不仅包含了函数的源代码等还有[[scope]],[[Scope]]属性中保存了一条用来初始化作用域链，其指向就是当前的变量对象(全局变量对象)</p>
<blockquote>
<p>注意此时并没创建函数相应的执行环境<br><img src="http://i.imgur.com/GGGcGON.png" alt="p2"></p>
</blockquote>
<h2 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h2><pre><code>//myScript.js 
&quot;use strict&quot;    
var a=1;
var b=2; 
function foo()&#123;
    var c=3;
    var d=4;
    console.log(c+d);
&#125;;
foo();
</code></pre>
<p>执行至<code>foo()</code>,函数被调用，产生相应的执行环境，之后被推入执行环境栈顶，</p>
<blockquote>
<p>此时产生的执行环境中的作用域链由之前函数定义时的[[scope]]而来，作用链的前端为foo的变量对象，由于这个环境是函数，创建活动对象并将其作为变量对象<br><img src="http://i.imgur.com/ocIbFzQ.png" alt="p3"></p>
</blockquote>
<h2 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h2><p>调用foo()结束后，其执行环境会被弹出执行栈，<br><img src="http://i.imgur.com/gDcXp4r.png" alt="p4"></p>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>1.作用域链是本质上是一个指向变量对象的指针列表，它只是引用但不实际包含变量对象。<br>2.AO中包含了函数的形参、arguments对象、this对象、以及局部变量和内部函数的定义，然后AO会被推入作用域链的顶端。</p>
<blockquote>
<p>感觉AO和VO里的内容差不多</p>
</blockquote>
<h1 id="EC和VO的产生过程"><a href="#EC和VO的产生过程" class="headerlink" title="EC和VO的产生过程"></a>EC和VO的产生过程</h1><p>当函数被调用时进入EC的产生阶段</p>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><blockquote>
<p><a href="http://www.jianshu.com/p/4881610a8c24">简书</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.cnblogs.com/jacksplwxy/p/6725850.html">偶尔看到的个人挺赞同的</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.cnblogs.com/jacksplwxy/p/6725850.html">执行环境、变量对象、活动对象和作用域链</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/dwqs/blog/issues/18">皮卡丘的讲解</a></p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000004676747">segmentfault作用域javascript1</a></p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000008614579">segmentfault作用域javascript2</a></p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000000533094">segmentfault作用域javascript3</a></p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000009247123">讲了执行环境和变量对象的创建和执行过程，很有用</a></p>
</blockquote>
<blockquote>
<p><a href="http://blog.csdn.net/u010425776/article/details/53557942">作用域</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript闭包</title>
    <url>/2017/05/12/javascript%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h1><h2 id="闭包的产生"><a href="#闭包的产生" class="headerlink" title="闭包的产生"></a>闭包的产生</h2><p>我觉得是因为闭包函数的作用域链中保存着包裹函数的活动对象，正因保留着引用，导致包裹函数不会被垃圾回收</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol>
<li>闭包会引用包含函数的整个活动对象</li>
<li>是个函数</li>
</ol>
<h1 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h1><ol>
<li>模拟私有方法</li>
</ol>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>作用域链和闭包脱不了干系，作用域链部分可以查看<a href="/2017/05/10/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F/" title="javascript作用域">javascript作用域</a></p>
<h1 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h1>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js回顾(一)</title>
    <url>/2017/03/06/js%E5%9B%9E%E9%A1%BE-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="对象和原型"><a href="#对象和原型" class="headerlink" title="对象和原型"></a>对象和原型</h1><h2 id="几种常见的创建对象方法"><a href="#几种常见的创建对象方法" class="headerlink" title="几种常见的创建对象方法##"></a>几种常见的创建对象方法##</h2><p>1.通过对象字面量构造</p>
<pre><code>var contact1=&#123;
    name:&quot;zhao&quot;,
    sex:&quot;male&quot;
&#125;
</code></pre>
<p>通过此方法构造的对象，其[[prototype]]指向Object.prototype</p>
<p>2.通过构造函数</p>
<pre><code>function Contact(name,sex)&#123;
    this.name=name;
    this.sex=sex;
    this.getName=function()&#123;
        return name;
    &#125;
&#125;
var contact1=new Contact()
contact1.__proto__==Contact.prototype //true
</code></pre>
<p>每个函数都有一个prototype属性，其所指向的对象带有constructor属性，这一属性指向函数自身,eg,本例中，Contact.prototype.constructor==Contact</p>
<p>3.通过函数Object.create构造</p>
<pre><code>var contact=&#123;
    name:&quot;zhao&quot;,
    sex:&quot;male&quot;
&#125;
var contact1=Object.create(contact);
</code></pre>
<p>contact1的[[prototype]]指向contact</p>
<h1 id="js中-proto-和prototype的区别和关系？"><a href="#js中-proto-和prototype的区别和关系？" class="headerlink" title="js中__proto__和prototype的区别和关系？"></a>js中__proto__和prototype的区别和关系？</h1><p>常说js中一切都是对象，但基本数据类型不是对象，基本数据类型没有方法和属性 ，当我们调用方法时候会封装出一个对象，（wrapper对象是什么）<br>首先，几乎所有对象都有[[prototype]]属性，在es5中这是个隐藏属性，指向此对象的原型。es5中用Object.getPrototypeOf函数获得一个对象的[[prototype]]。es6中，使用Object.setPrototypeOf可以直接修改一个对象的[[prototype]]</p>
<blockquote>
<p>很多浏览器都给每个对象提供__proto__属性(不标准，不推荐用)，我觉得可以理解为就是[[prototype]]，</p>
</blockquote>
<p><img src="http://i.imgur.com/0G4COrD.png" alt="关系图"></p>
<p>1.方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。<br>2.方法(Function)方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。好啦，知道了这两个基本点，我们来看看上面这副图。<br>1.构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。<br>2.原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。<br>3.实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性__proto__，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。另外：构造函数Foo()除了是方法，也是对象啊，它也有__proto__属性，指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。其实除了Foo()，Function(), Object()也是一样的道理。原型对象也是对象啊，它的__proto__属性，又指向谁呢？同理，指向它的构造函数的原型对象呗。这里是Object.prototype.最后，Object.prototype的__proto__属性指向null。<br>总结：<br>1.对象有属性__proto__,指向该对象的构造函数的原型对象。<br>2.方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。</p>
<p>看一下几种常见构造一个对象的方法，决定了一个对象的[[prototype]]属性</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://blog.csdn.net/u010425776/article/details/53617292">对象与原型</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组</title>
    <url>/2017/06/20/js%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>js中数据类型分基本数据类型和引用数据类型两种，对象便是某个特定引用类型的实例。<br>Array构造函数在web中作为window对象的一个属性</p>
<h1 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h1><ol>
<li><code>var array=[];</code></li>
<li><code>var array=new Array();</code></li>
</ol>
<blockquote>
<p><code>var array=new Array(5)</code>接收的参数作为新建数组的长度<br><code>var array=new Array(&quot;param1&quot;,&quot;param2&quot;,&quot;param3&quot;)</code>直接接收数组成员作为参数</p>
</blockquote>
<h1 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h1><p>数组的长度</p>
<pre><code>var family = [&quot;child&quot;,&quot;mother&quot;,&quot;father&quot;];
family.length    //3
</code></pre>
<p>js中，数组的长度可变，会随着数据的添加而增长，所以会出现所含项数和length属性值不等的情况，如下</p>
<pre><code>var family = [&quot;child&quot;,&quot;mother&quot;,&quot;father&quot;];
family.length=4;
family[3]    //undefined
family.length=2;
family[2]    //undefined
</code></pre>
<h1 id="数组的检测"><a href="#数组的检测" class="headerlink" title="数组的检测"></a>数组的检测</h1><p>数组的检测不能使用typeof，因为返回的是object</p>
<blockquote>
<p>说到这个我想起来我本来有个误解，以为typeof只能返回js数据类型的名称呢，</p>
</blockquote>
<blockquote>
<p>即<code>undefined</code>,<code>null</code>,<code>boolean</code>,<code>string</code>,<code>number</code>,<code>object</code>,<code>symbol(es6新增)</code>。其实检测function类型时会返回function，具体typeof的返回值看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">这里</a></p>
</blockquote>
<p>然后就是这个方法，instanceof其实从字面上就可以看出它是干嘛的了，可以理解为判断对象是否是被右边的家伙所实例化（语无伦次）。</p>
<p>摘自js高程</p>
<p>instanceof操作符在存在多个作用域(像一个页面包含多个frame)的情况下，也是问题多多。一个经典的例子</p>
<pre><code>var isArray = value instanceof Array
</code></pre>
<p>以上代码要返回true，value必须是一个数组，而且还必须与Array构造函数在同个全局作用域中。（别忘了，Array是window 的属性）如果value是在另一个frame中 定义的数组。那么以上代码就会返回false。</p>
<p>推荐用这种方法<br>    object.prototype.toString.call(value)</p>
<blockquote>
<p>如果value为数组的话会返回[object Array]，同时这种方法也可以检测原生函数或正则表达式，分别返回[object Function]和[object RegEXp]</p>
</blockquote>
<h1 id="数组的转化方法"><a href="#数组的转化方法" class="headerlink" title="数组的转化方法"></a>数组的转化方法</h1><p>所有对象都具有toLocaleString(),toSring()和valueOf()方法，所以数组也不例外。</p>
<p>还有join()</p>
<h2 id="数组转化为对象"><a href="#数组转化为对象" class="headerlink" title="数组转化为对象"></a>数组转化为对象</h2><h1 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h1><h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>栈数据结构的访问规则是LIFO（last-in-first-out,后进先出）,两个方法push()和pop()</p>
<blockquote>
<p>我我觉得可以理解为操作一直在数组尾巴处进行</p>
</blockquote>
<p>push()返回操作后数组的长度。</p>
<p>pop()删除并返回数组最后一项</p>
<p>几个例子</p>
<pre><code>var colors = new Array();
colors.push(&quot;red&quot;,&quot;green&quot;);    //返回数组的长度2，此时colors=[&quot;red&quot;,&quot;green&quot;]
colors.pop();                  //返回数组的最后一项&quot;green&quot;,此时colors=[&quot;red&quot;]
</code></pre>
<h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>队列数据的访问规则是FIFO(first-in-first-out,先进先出)，</p>
<p>shift(),移除数组中的第一个项并返回该项，同时将数组长度减1。</p>
<p>unshift(),在数组前端添加任一个项并返回新数组的长度。</p>
<p>例子如下</p>
<pre><code>var colors = new Array();
colors.push(&quot;white&quot;,&quot;blue&quot;);
colors.shift();              //返回数组的第一项&quot;white&quot;,此时colors=[&quot;white&quot;]
colors.unshift(&quot;purple&quot;,&quot;yellow&quot;);  //返回数组的长度3,此时colors=[&quot;purple&quot;,&quot;yellow&quot;,&quot;white&quot;]   
</code></pre>
<h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p>reverse(),将原数组的顺序颠倒，返回一个数组。</p>
<p>sort(),会先调用每个项的toString()方法，然后比较得到的字符串，用以确定排序</p>
<blockquote>
<p>数组各项是数字可能会出问题，因为仍然会先转化为字符串在进行排序，这样的话比较的就是各自的字符编码（ASCII），如下</p>
</blockquote>
<pre><code>var numbs=[0,1,5,10,15];
numbs.sort();
console.log(numbs);     //[0,1,10,15,5]
console.log(&quot;5&quot;.charCodeAt());      //53
console.log(&quot;10&quot;.charCodeAt());     //49
</code></pre>
<p>但是sort()方法可以接收一个比较函数作为参数，用以决定那个值位于哪个值的前面。比较函数的返回值如下</p>
<ol>
<li><p>返回负数，表示value1应该位于value2之前</p>
</li>
<li><p>返回0，表示两个参数相等</p>
</li>
<li><p>返回正数，表示value1应该位于value2之后</p>
<p> function compare(value1,value2){</p>
<pre><code> if(value1 &lt; value2)&#123;
     return -1;
 &#125;else if(value1 &gt; value2)&#123;
     return 1;
 &#125;else &#123;
     return 0;
 &#125;
</code></pre>
<p> }</p>
<p> var numbs=[0,1,5,10,15];<br> numbs.sort(compare);<br> console.log(numbs);      //[0,1,5,10,15]</p>
</li>
</ol>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>concat()拼接数组，直接上例子</p>
<pre><code>var colors = [&quot;red&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;green&quot;];
var colors2 = colors.concat(&quot;purple&quot;,[&quot;black&quot;,&quot;white&quot;]);
console.log(colors2);   //[&quot;red&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;purple&quot;,&quot;black&quot;,&quot;white&quot;]
</code></pre>
<p>slice()接收一个或两个参数，即要返回起始至末尾或者起始和结束位置(不包括)的项，上例子</p>
<blockquote>
<p>注意 <code>slice()</code> 方法可以不传参数，看下面例子</p>
</blockquote>
<blockquote>
<p>注意参数可以为负值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&quot;red&quot;</span>,<span class="string">&quot;yellow&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;green&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> colorss = colors.slice() <span class="comment">// 相当于colors.slice(0)</span></span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors4 = colors.slice(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> colors5 = colors.slice(-<span class="number">3</span>,-<span class="number">2</span>);  <span class="comment">//colors.length-3==1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors3);   <span class="comment">//[&quot;yellow&quot;, &quot;blue&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors4);   <span class="comment">//[&quot;yellow&quot;]</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>concat()和slice()不会影响原有数组</p>
</blockquote>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>splice方法很强大，可以实现数组的删除，插入，替换功能，语法为：</p>
<pre><code>arrayObject.splice(index,howmany,item1,.....,itemX);
index  必需。整数，规定添加删除项目的位置，使用负数可从数组结尾处规定位置。
howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。
item1, ..., itemX   可选。向数组添加的新项目。
</code></pre>
<p>返回删除的项组成的数组，如果没有删除的项，返回一个空数组。</p>
<blockquote>
<p>该方法会改变原始数组。</p>
</blockquote>
<h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p>indexOf()和lastIndexOf()，都接收两个参数，要查找的项和表示查找起点的索引(可选)</p>
<p>不同点是indexOf从头开始找，lastIndexOf从尾巴找</p>
<p>都返回要查找的项在数组中的位置，没找到的话返回-1</p>
<p>indexOf()从</p>
<blockquote>
<p>想起来，字符串类型也有indexOf()方法，比如检测cookie中是否含user字段<code>document.cookie.indexOf(&quot;user=&quot;)</code>，顺带一提，<code>document.cookie</code>是一串字符串</p>
</blockquote>
<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><ul>
<li>every()</li>
<li>filter()</li>
<li>forEach()</li>
<li>map()</li>
<li>some()</li>
</ul>
<p>让我缓口气，过两天在写完</p>
<h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>jq中，数组操作新增了each()</p>
<h1 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h1><p>像数组，有和数组相同的属性和方法，如length等。</p>
<ul>
<li>nodelist</li>
<li>argument</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="http://zxc8899.iteye.com/blog/1558298/">一瓢江湖</a></li>
<li><a href="http://www.jianshu.com/p/66b04163948b">简书</a></li>
<li>js高程</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx笔记</title>
    <url>/2020/10/23/nginx%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>像自己的 git 笔记一样，记录下自己安装以及使用的过程与心得，方便之后的查看</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 <strong>brew</strong> 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>正常情况下执行完此命令后是看不到什么输出的 （实际上已经执行成功了）</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/40c136bfgy1gk3p0cgqt2j20g7037t9x.jpg" alt="nginxStart.png"></p>
<p>启动后可通过如下命令控制服务器的状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s signal</span><br></pre></td></tr></table></figure>

<p><strong>signal</strong>的值可能如下</p>
<ul>
<li>stop — fast shutdown</li>
<li>quit — graceful shutdown</li>
<li>reload — reloading the configuration file</li>
<li>reopen — reopening the log files</li>
</ul>
<blockquote>
<p>使用 quit 参数会在主线程处理完当前请求后停止 nginx 线程</p>
</blockquote>
<p>每次修改完配置文件后需要重新执行 reload 命令</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote>
<p>有时可能会登录一个不熟悉的服务器，需要看下 nginx 配置的位置，可使用 <code>nginx -t</code> 命令查看下位置</p>
</blockquote>
<p>在 mac 系统中，相关的几个路径</p>
<ul>
<li><code>/usr/local/etc/nginx/nginx.conf</code> （nginx 配置文件路径）</li>
<li><code>/usr/local/var/www</code> （nginx 服务器默认的根目录）</li>
<li><code>/usr/local/Cellar/nginx/1.17.9</code> （nginx 的安装路径）</li>
<li><code>/usr/local/var/log/nginx/error.log</code> （nginx 默认的日志路径）</li>
</ul>
<p><strong>nginx</strong>配置部分是重中之重</p>
<p>这里举一个例子，下面的配置了服务器的 监听端口，重定向位置，代理服务</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">8089</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   html/web-mobile;                <span class="comment">#入口目录</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.0.235:8091;  <span class="comment">#代理的目标服务器</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul>
<li><strong>nginx</strong> 有一个主线程和若干个工作线程</li>
</ul>
<h2 id="about"><a href="#about" class="headerlink" title="about"></a>about</h2><ul>
<li><a href="https://nginx.org/en/docs/beginners_guide.html">beginner’s guide</a></li>
<li><a href="https://blog.imkasen.com/nginx-beginner-guide-zh.html">beginner’s guide 翻译</a></li>
</ul>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>node(一)</title>
    <url>/2017/03/01/node-%E4%B8%80/</url>
    <content><![CDATA[<p>开始正式学习node，之前看过node即学即用，敲了遍书上的代码，有点晕晕的，之后很长时间没接触node了，现在下决心每天花些时间捣鼓下。</p>
<span id="more"></span>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在这里主要是记笔记，按照教程尝试搭建使用 Express + MongoDB 搭建多人博客，记录些要点和体会</p>
<blockquote>
<p>参考了<a href="https://github.com/nswbmw/N-blog">使用 Express + MongoDB 搭建多人博客</a></p>
</blockquote>
<h1 id="安装配置环境"><a href="#安装配置环境" class="headerlink" title="安装配置环境"></a>安装配置环境</h1><p>安装nodejs，LTS是长期支持版本，current是最新版，支持最新语言特性(比如更全的es6)</p>
<p>n和nvm是两个常用的nodejs版本管理工具，nvm不支持windows</p>
<blockquote>
<p>参考<a href="http://taobaofed.org/blog/2015/11/17/nvm-or-n/">这个</a><br>还有阮一峰老师的<a href="http://es6.ruanyifeng.com/#docs/intro">es6入门</a></p>
</blockquote>
<p>nrm管理npm源的工具，目测修改了源之后npm==cnpm了</p>
<p>安装mongoDB遇到一个坑，执行</p>
<pre><code> &quot;C:\Program Files\MongoDB\Server\3.4\bin\mongod.exe&quot; --dbpath F:\practice\mongo
</code></pre>
<p>报错</p>
<pre><code> $ &quot;C:\Program Files\MongoDB\Server\3.4\bin\mongod.exe&quot; --dbpath F:\practice\mongo
17-03-02T14:55:01.854+0800 I CONTROL  [initandlisten] MongoDB starting :     d=7440 port=27017 dbpath=F:practicemongo 64-bit host=DESKTOP-KP92M3V
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten] targetMinOS: Windows 7/    ndows Server 2008 R2
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten] db version v3.4.2
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten] git version:     76e40c105fc223b3e5aac3e20dcd026b83b38b
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten] OpenSSL version:     enSSL 1.0.1u-fips  22 Sep 2016
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten] allocator: tcmalloc
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten] modules: none
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten] build environment:
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten]     distmod:     08plus-ssl
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten]     distarch: x86_64
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten]     target_arch: x86_64
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten] options: &#123; storage: &#123;     Path: &quot;F:practicemongo&quot; &#125; &#125;
17-03-02T14:55:01.855+0800 I STORAGE  [initandlisten] exception in     itAndListen: 29 Data directory F:practicemongo not found., terminating
17-03-02T14:55:01.855+0800 I NETWORK  [initandlisten] shutdown: going to     ose listening sockets...
17-03-02T14:55:01.855+0800 I NETWORK  [initandlisten] shutdown: going to     ush diaglog...
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten] now exiting
17-03-02T14:55:01.855+0800 I CONTROL  [initandlisten] shutting down with     de:100
</code></pre>
<p>说F:practicemongo not found，不知道为什么会这样，直接执行</p>
<pre><code> &quot;C:\Program Files\MongoDB\Server\3.4\bin\mongod.exe&quot;
</code></pre>
<p>又说 F:\data\db\ not found.</p>
<p>我就只好在F盘下新建data\db，然后就成功了</p>
<p>打开Robomongo,<a href="http://blog.robomongo.org/">Robomongo</a> 是一个基于 Shell 的跨平台开源 MongoDB 可视化管理工具，支持 Windows、Linux 和 Mac，嵌入了 JavaScript 引擎和 MongoDB mongo，</p>
<blockquote>
<p>试着插入一条数据结果不知道怎样看不到了</p>
</blockquote>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime 安装小结</title>
    <url>/2016/12/22/sublime-%E5%AE%89%E8%A3%85%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="sublime-3"><a href="#sublime-3" class="headerlink" title="sublime 3"></a>sublime 3</h1><p>sublime大家都知道啦，用了近一年了，感情颇深。之前用了sublime2，感觉最大的不同是sublime3的启动速度飞快，之后一直在用别人放出来装了各种插件的3，结果近几个月想要下载新的插件时发现竟然装不了，哈，值此一周年之际，自己重新捣鼓下3.</p>
<span id="more"></span>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装就不多说了，官网<a href="https://www.sublimetext.com/3" title="sublime3下载">sublime3下载</a>。</p>
<blockquote>
<p>需要注意，最好在翻墙状态下，反正我没翻墙下不了。</p>
</blockquote>
<p>安装可以选中<strong>explorer context menu</strong>选项，意思是右击时显示open with sublime，方便编辑，不想显示中文可以去注册表改一下</p>
<p><img src="http://i.imgur.com/UyAYoF3.png"></p>
<p>重点来了，额，不购买的话会一直提示，比较烦</p>
<blockquote>
<p>最好有条件还是支持正版</p>
</blockquote>
<p>在简书上看到注册码<a href="http://www.jianshu.com/p/04e1b65dd2c0" title="sublime3注册码">sublime3注册码</a><br>博主也在定期更新（非常感谢大神，大神的博客很赞）。help中填入注册码就行啦</p>
<blockquote>
<p>留一下，有好几个的，填一个就行啦</p>
</blockquote>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><ul>
<li>直接装</li>
</ul>
<p>preferences&gt;browse packages…</p>
<p><img src="http://hiphotos.baidu.com/exp/pic/item/0e655ca7d933c8954e7c86f6d31373f0830200f9.jpg"></p>
<p>下载地址：<a href="https://sublime.wbond.net/Package%20Control.sublime-package" title="package control">package control</a></p>
<p>放进去:</p>
<p><img src="http://hiphotos.baidu.com/exp/pic/item/8a95ad1c8701a18b4eb90cc29c2f07082938feaa.jpg"></p>
<blockquote>
<p>建议用这个方法，我试了用console命令报错 好像是can not open XXX<br>,换了另外一个网上的命令可以下，但是速度很慢</p>
</blockquote>
<ul>
<li>用package control组件安装</li>
</ul>
<p>这个不多说啦，附上官方介绍</p>
<p><a href="https://packagecontrol.io/installation" title="packagecontrol installation">packagecontrol installation</a></p>
<h2 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h2><blockquote>
<p>这里只记录我接触到的</p>
</blockquote>
<p>插件的安装嘛，ctrl+shift+p调出控制台，选到package controll install，然后等，再次弹出控制台输入想要安装的插件，选中 安装 等待</p>
<p>注意要留意下方的状态</p>
<ol>
<li><p>emmet<br>神器，谁用谁知道，补全代码等等，附上用法<br><a href="https://packagecontrol.io/packages/Emmet" title="Emmet">Emmet</a></p>
</li>
<li><p>markdownEditing<br>这个用来写博客，记得先ctrl+shift+p设置成markdown格式，写这篇文就遇到个坑，我用的<a href="markdownpad" title="http://markdownpad.com/">markdownpad</a>的图床是 <a href="Imgur" title="http://imgur.com/">Imgur</a>，额，不翻墙上传不了图片</p>
</li>
<li><p>angular<br>对于指令和服务，鼠标移上去可以看到初始化的地方</p>
</li>
<li><p>sublimeLinter<br>语法错误检测，这个组件依赖于nodeJS下的jshint，所以还要通过npm安装jshint的jshint</p>
<p> npm install -g jshint</p>
</li>
<li><p>SideBarEnhancements<br>侧栏右键功能增强</p>
</li>
<li><p>Alignment<br>等号对齐（Ctrl+Alt+A）</p>
</li>
<li><p>Bracket Highlighter<br>代码匹配</p>
</li>
<li><p>prettify<br>HTML-CSS-JS Prettify  code format  代码格式化</p>
</li>
<li><p>color Highlighter<br>实时看到颜色</p>
</li>
<li><p>html/js/css prettify<br>ctrl+shift+h一键格式，代码对齐啥的</p>
</li>
<li><p>localhistory<br>历史记录</p>
</li>
</ol>
<hr>
<blockquote>
<p>2017.5</p>
</blockquote>
<ol start="12">
<li><p>nodejs<br>支持对node的语法补全等</p>
</li>
<li><p>SublimeLinter-contrib-eslint<br>使用eslint来进行代码规范检查</p>
</li>
<li><p>Vue Syntax Highlight<br>.vue结尾的代码也会变得五颜六色</p>
</li>
</ol>
<p>持续更新中  …</p>
]]></content>
      <categories>
        <category>sublime</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>node 相关依赖</title>
    <url>/2020/12/21/node-%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>sublime3主题和BracketHightLighter插件配置</title>
    <url>/2017/07/12/sublime3%E4%B8%BB%E9%A2%98%E5%92%8CBracketHightLighter%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>sublime有很高的配置性，这里说下他的主题部分和插件(BracketHightLighter)的相关配置。</p>
<span id="more"></span>

<h1 id="sublime主题"><a href="#sublime主题" class="headerlink" title="sublime主题"></a>sublime主题</h1><p>我的sublime版本为3126</p>
<p>网上有很多主题，可通过package control来安装，就不说啦</p>
<h1 id="BracketHightLighter插件配置"><a href="#BracketHightLighter插件配置" class="headerlink" title="BracketHightLighter插件配置"></a>BracketHightLighter插件配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装不说了，直接在package control中安装</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开</p>
<p>Preferences  &gt;  Package Settings  &gt;  BracketHighlighter  &gt;  Bracket Settings</p>
<p>不同版本的sublime会有些差异，sublime3的话一般配置分为</p>
<ul>
<li>默认配置（用户不可更改，以防你改残了）</li>
<li>用户配置（这部分随便你改，大不了最后直接删掉）</li>
</ul>
<p>这个就像css一样，用户配置的部分会覆盖默认的配置</p>
<p>现在，你看到两栏，左边就是默认配置啦，改不了的，右边就是用户配置，现在空空的向其中添加如下，</p>
<blockquote>
<p>其中，根据英文名就可以知道default(默认)，curly(大括号)，round(小括号)，square(方括号)……是分别配置各自的显示信息的啦</p>
</blockquote>
<blockquote>
<p>style 属性就是展示的类型了，默认为下划线(underline)，个人偏好都改为高亮(highlight)</p>
</blockquote>
<blockquote>
<p>color 的配置稍微繁琐，放到下面讲</p>
</blockquote>
<pre><code> &#123;
 &quot;bracket_styles&quot;: 
    &#123;
        &quot;default&quot;: &#123;
        &quot;icon&quot;: &quot;dot&quot;, 
        &quot;color&quot;: &quot;entity.name.class&quot;, 
        &quot;color&quot;: &quot;brackethighlighter.default&quot;, 
        &quot;style&quot;: &quot;highlight&quot; 
        &#125;, 
        &quot;unmatched&quot;: &#123;
        &quot;icon&quot;: &quot;question&quot;, 
        &quot;color&quot;: &quot;brackethighlighter.unmatched&quot;, 
        &quot;style&quot;: &quot;highlight&quot; 
        &#125;, 
        &quot;curly&quot;: &#123;
        &quot;icon&quot;: &quot;curly_bracket&quot;, 
        &quot;color&quot;: &quot;brackethighlighter.curly&quot;, 
        &quot;style&quot;: &quot;highlight&quot; 
        &#125;, 
        &quot;round&quot;: &#123;
        &quot;icon&quot;: &quot;round_bracket&quot;, 
        &quot;color&quot;: &quot;brackethighlighter.round&quot;, 
        &quot;style&quot;: &quot;highlight&quot; 
        &#125;, 
        &quot;square&quot;: &#123;
        &quot;icon&quot;: &quot;square_bracket&quot;, 
        &quot;color&quot;: &quot;brackethighlighter.square&quot;, 
        &quot;style&quot;: &quot;highlight&quot; 
        &#125;, 
        &quot;angle&quot;: &#123;
        &quot;icon&quot;: &quot;angle_bracket&quot;, 
        &quot;color&quot;: &quot;brackethighlighter.angle&quot;, 
        &quot;style&quot;: &quot;highlight&quot; 
        &#125;, 
        &quot;tag&quot;: &#123;
        &quot;icon&quot;: &quot;tag&quot;, 
        &quot;color&quot;: &quot;brackethighlighter.tag&quot;, 
        &quot;style&quot;: &quot;highlight&quot; 
        &#125;, 
        &quot;single_quote&quot;: &#123;
         &quot;icon&quot;: &quot;single_quote&quot;, 
         &quot;color&quot;: &quot;brackethighlighter.quote&quot;, 
         &quot;style&quot;: &quot;highlight&quot; 
        &#125;, 
        &quot;double_quote&quot;: &#123;
        &quot;icon&quot;: &quot;double_quote&quot;, 
        &quot;color&quot;: &quot;brackethighlighter.quote&quot;, 
        &quot;style&quot;: &quot;highlight&quot; 
        &#125;, 
        &quot;regex&quot;: &#123;
        &quot;icon&quot;: &quot;regex&quot;, 
        &quot;color&quot;: &quot;brackethighlighter.quote&quot;, 
        &quot;style&quot;: &quot;outline&quot;  
        &#125; 
    &#125; 
&#125;
</code></pre>
<p>BracketHightLighter插件默认是使用下划线的（underline）</p>
<h2 id="color的配置"><a href="#color的配置" class="headerlink" title="color的配置"></a>color的配置</h2><p>比如其中的</p>
<pre><code>&quot;curly&quot;: &#123;
        &quot;icon&quot;: &quot;curly_bracket&quot;, 
        &quot;color&quot;: &quot;brackethighlighter.curly&quot;, 
        &quot;style&quot;: &quot;highlight&quot; 
        &#125;, 
</code></pre>
<p>color属性值为brackethighlighter.curly，这个在哪呢</p>
<p>首先要找到正在使用的主题,打开Packages文件夹，再打开User  &gt;  Preferences.sublime-settings<br>第一行就是正在使用的主题配置</p>
<p>之后(Preferences  &gt;  Browse Packages)打开Packages文件夹，User  &gt;   Color Highlighter    &gt;   themes</p>
<p>我试用的Monokai.tmTheme，打开，向<code>&lt;array&gt;&lt;/array&gt;</code>添加</p>
<pre><code>    &lt;dict&gt;
        &lt;key&gt;name&lt;/key&gt;
        &lt;string&gt;Bracket Curly&lt;/string&gt;
        &lt;key&gt;scope&lt;/key&gt;
        &lt;string&gt;brackethighlighter.curly&lt;/string&gt;
        &lt;key&gt;settings&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;foreground&lt;/key&gt;
            &lt;string&gt;#CC99CC&lt;/string&gt;
        &lt;/dict&gt;
    &lt;/dict&gt;
</code></pre>
<p>保存后就发现花括号高亮颜色就变成粉红色啦，其他配置同理</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://docs.sublimetext.info/en/latest/reference/color_schemes.html">color schemes</a></li>
<li><a href="https://facelessuser.github.io/BracketHighlighter/customize/#configuring-highlight-style">BracketHighlighter set color</a></li>
</ul>
]]></content>
      <categories>
        <category>sublime</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>value和ng-value</title>
    <url>/2017/02/23/value%E5%92%8Cng-value/</url>
    <content><![CDATA[<p>开年第一篇，前两周赶进度特别忙，基本重构了整个系统，也踩了不少的坑，其中就有angular指令ng-value和value这俩货</p>
<blockquote>
<p>类似的还有ng-disabled和disabled等</p>
</blockquote>
<h1 id="ng-value-amp-amp-value"><a href="#ng-value-amp-amp-value" class="headerlink" title="ng-value&amp;&amp;value"></a>ng-value&amp;&amp;value</h1><h1 id="ng-disabled-amp-amp-disabled"><a href="#ng-disabled-amp-amp-disabled" class="headerlink" title="ng-disabled&amp;&amp;disabled"></a>ng-disabled&amp;&amp;disabled</h1><p>上来先举个正确的例子</p>
<pre><code>ng-disabled=&quot;!(address.selected&amp;&amp;filterOptions.filterText.endTime&amp;&amp;filterOptions.filterText.startTime)&quot;
</code></pre>
<blockquote>
<p>这个是账户系统中的原例，注意逻辑关系的书写</p>
</blockquote>
<p><del>ng-disabled=”false“</del></p>
<p>上面一条是错的</p>
<blockquote>
<p>注意disable存在时，表单不会对其校验，可使用visible属性</p>
</blockquote>
<h1 id="ng-if"><a href="#ng-if" class="headerlink" title="ng-if"></a>ng-if</h1><p>这里要特别注意ng-if和ng-show的区别</p>
<p>ng-if = false 时，相应的标签元素在调试器里消失（不知道是否被移出了dom），且不占空间。而<br>ng-show = false 时 相应的的元素还是在dom中的，</p>
<p>如下</p>
<ul>
<li>ng-if 在后面表达式为 true 的时候才创建这个 dom 节点，ng-show 是初始时就创建了，用 display:block 和 display:none 来控制显示和不显示。</li>
<li>ng-if 会（隐式地）产生新作用域，ng-switch 、 ng-include 等会动态创建一块界面的也是如此。 </li>
</ul>
]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title>vue和angular异同</title>
    <url>/2020/11/04/vue%E5%92%8Cangular%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>最近重新看回 angular，其1.X版本作为第一个接触到的框架，给我留下了深刻的印象，近两年的项目用的基本都是vue，感觉现在是时候总结记录下他们的异同了</p>
<span id="more"></span>

<p>因为 vue3 还没上手实际项目，以下讨论的 vue 指的是vue2.X 版本</p>
<p>从以下几个方面聊聊</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul>
<li><strong>angular</strong> 有着较为统一的目录结构，一般每个功能页面（视图-由组件和关联的模版构成）都有，template，component，service，样式文件（css,scss,less），举例如下</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/40c136bfgy1gke4flbxt4j20fe09ijs6.jpg" alt="WX20201105-110902@2x.png"></p>
<ul>
<li><p><strong>angular</strong> 在功能页面之上，还有更高层级的模块（module）概念，每个 <strong>angular</strong> 应用都有一个根模块，通常命名为 AppModule。根模块提供了用来启动应用的引导机制。 一个应用通常会包含很多特性模块。</p>
</li>
<li><p><strong>vue</strong> 的目录就比较松散了，每个人都有自己的分层想法，不过还是建议以 vue 的<strong>风格指南</strong>作为开发中的标准</p>
</li>
<li><p><strong>vue</strong> 其实是由一个个组件构成的，没有 angular 这么多别的东西，vue 的入口文件为 main.js</p>
</li>
</ul>
<h2 id="模版部分"><a href="#模版部分" class="headerlink" title="模版部分"></a>模版部分</h2><ul>
<li><strong>vue</strong> 是用了虚拟dom（virtual dom），展示的为编译后的模版</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/40c136bfgy1gke51ze13gj20fk0gg406.jpg" alt="WX20201105-112937.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/40c136bfgy1gke52nf3mlj20pc0epacq.jpg" alt="WX20201105-112905.png"></p>
<ul>
<li><strong>angular</strong> 模版基于 web component 标准，如下，分别为代码和Google开发者工具中的显示</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/40c136bfgy1gke4k6fl7uj211k0gctcj.jpg" alt="WX20201105-111250@2x.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/40c136bfgy1gke4kj5aerj20rp08agnu.jpg" alt="WX20201105-111324.png"></p>
<h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><ul>
<li><strong>angular</strong> 的脚手架非常强大，可以使用其中的命令创建，删除 module，service，component，route 等，并且有自动注入的功能，推荐使用命令创建模块组件等</li>
</ul>
<blockquote>
<p>经常会给脚手架命令加上参数，比如 <code>ng new routing-app --routing</code> 生成一个带有应用路由模块（AppRoutingModule）的基本 Angular 应用</p>
</blockquote>
<ul>
<li><strong>vue</strong> 等脚手架没有这么多辅助开发等命令，不过可以使用 <code>vue ui</code> 打开一个项目的可视化管理页面，进行包的增删操作等</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/40c136bfgy1gkebrx59lkj22l61jogwc.jpg" alt="WX20201105-152425@2x.png"></p>
]]></content>
      <tags>
        <tag>angular</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh相关</title>
    <url>/2020/07/14/zsh%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>zsh 相关的 <strong>iTerm2</strong> 和 <strong>oh my zsh</strong> 安装，以及相关主题配置</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开始接触命令行是在用windows的时候，那时就只是用来装装node之类的软件，后来装了 git bash，接触了些很好用的linux命令，就可以减少使用鼠标的次数啦，一定程度上来说还是很爽的。</p>
<p>之后碗切到了mac，Linux 命令就用的更爽啦(mac os 毕竟是基于 linux 的)，然后就接触到了 fish ，可以直接通过 fish ui 命令直接调出配置页面，可以直接调整文字大小啊，颜色啊，git分支提示，而且还有历史命令提示等功能，从此我的命令行就变得花花绿绿的。再后来，mac 大力推荐 zsh 了，因为 zsh 功能更加强大，所以也就有了本篇。</p>
<h1 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h1><p>安装 zsh 就不写了，因为 mac 本身就内置了，切换下就好</p>
<h1 id="安装-iTerm2"><a href="#安装-iTerm2" class="headerlink" title="安装 iTerm2"></a>安装 <strong>iTerm2</strong></h1><p><a href="https://www.iterm2.com/">iTerm2下载</a></p>
<blockquote>
<p>echo $SHELL  // 查看当前命令行解析器</p>
</blockquote>
<h1 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh my zsh"></a>oh my zsh</h1><p>方便安装插件，主题等</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过 curl</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过 wget</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>刚开始安装时会报 connect refuse 等的错误，我是通过修改 git host 配置来解决的</p>
</blockquote>
<h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>配置 <strong>.zshrc</strong> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>比如添加如下插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  bundler</span><br><span class="line">  dotenv</span><br><span class="line">  osx</span><br><span class="line">  rake</span><br><span class="line">  rbenv</span><br><span class="line">  ruby</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="安装-powerline-font"><a href="#安装-powerline-font" class="headerlink" title="安装 powerline font"></a>安装 powerline font</h2><p>有些主题需要 powerline font 的支持，所以配置主题前先安装 powerline font</p>
<p>有文章说需要先安装 powerline 再安装 powerline font，实际上我直接按照如下安装的，并没有先装 powerline</p>
<blockquote>
<p>可能其中的 install 脚本自带检查安装 powerline 的功能吧</p>
</blockquote>
<p>地址在此 <a href="https://github.com/powerline/fonts">powerline fonts</a></p>
<p>安装方法有多种，我使用了如下的安装方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># clone</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/powerline/fonts.git --depth=1</span><br><span class="line"><span class="comment"># install</span></span><br><span class="line"><span class="built_in">cd</span> fonts</span><br><span class="line">./install.sh</span><br><span class="line"><span class="comment"># clean-up a bit</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure>

<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>同样是修改 <strong>.zshrc</strong> 文件，修改如下配置项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;robbyrussell&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实安装 <strong>on my zsh</strong> 后，原本的 <strong>.zshrc</strong> 文件的内容会被覆盖，新的内容里增加了大量的说明内容，方便了 zsh 相关的配置</p>
</blockquote>
<h1 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h1><blockquote>
<p>推荐使用 <em>oh my zsh</em> 进行安装管理，具体安装可查看各插件官网</p>
</blockquote>
<ul>
<li><strong>git</strong> 可以快速输入 git 的缩写命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.oh-my-zsh/plugins/git/git.plugin.zsh  // 查看所有的git 缩写命令</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a></strong> 输入对命令正确对话会显示绿色，反之则显示红色</li>
<li><strong><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></strong> 类似 fish 的 历史命令记录功能</li>
</ul>
<p><img src="https://i.loli.net/2020/07/18/uqnvWVCp7IFyG9l.png" alt="image.png"></p>
<h1 id="上照"><a href="#上照" class="headerlink" title="上照"></a>上照</h1><p>主要是配置了颜色，然后加上背景图片</p>
<h1 id="go2shell"><a href="#go2shell" class="headerlink" title="go2shell"></a>go2shell</h1><p>很好用，集成在finder中，可以快速在当前目录下调出命令行工具</p>
<blockquote>
<p>记得选择 iterm2</p>
</blockquote>
<h1 id="about"><a href="#about" class="headerlink" title="about"></a>about</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/103672631">我觉得这篇文的 fish 部分写的很好</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37195261">知乎</a></li>
</ol>
]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>传输过程小记</title>
    <url>/2017/04/12/%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>微信授权相关</title>
    <url>/2020/02/22/%E5%BE%AE%E4%BF%A1%E6%8E%88%E6%9D%83%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>已经写过挺多授权部分的了，这里做写记录，并且附上相关的链接，以便后续查阅</p>
<span id="more"></span>

<h1 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h1><p>其实官网文档已经相当之详细了，这里特地记录下每一步骤实现所用的代码以及相关的工具函数</p>
<blockquote>
<p>所以重点还是要看看官方文档</p>
</blockquote>
<h2 id="1-获取code"><a href="#1-获取code" class="headerlink" title="1.获取code"></a>1.获取code</h2><p>获取code方法如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatAuth</span> (<span class="params">appId, redirectUri, responseType, scope, state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&#x27;https://open.weixin.qq.com/connect/oauth2/authorize&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> queryString = <span class="string">&#x27;appid=&#x27;</span> + appId + <span class="string">&#x27;&amp;redirect_uri=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(redirectUri) + <span class="string">&#x27;&amp;response_type=&#x27;</span> + responseType + <span class="string">&#x27;&amp;scope=&#x27;</span> + scope + <span class="string">&#x27;&amp;state=&#x27;</span> + state</span><br><span class="line">  location.href = url + <span class="string">&#x27;?&#x27;</span> + queryString + <span class="string">&#x27;#wechat_redirect&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-通过code换取网页授权-access-token-和-openid"><a href="#2-通过code换取网页授权-access-token-和-openid" class="headerlink" title="2.通过code换取网页授权 access_token 和 openid"></a>2.通过code换取网页授权 access_token 和 openid</h2><p>一般获取access_token 和 openid 都是由后台获取到，因为获取上面两个参数除了code外还需要传secret参数，出于安全考虑不会写在前端(参照文档)</p>
<h2 id="3-刷新access-token-如果需要"><a href="#3-刷新access-token-如果需要" class="headerlink" title="3.刷新access_token (如果需要)"></a>3.刷新access_token (如果需要)</h2><p>access_token scope为 snsapi_base 时，access_token似乎没啥用处</p>
<h2 id="4-拉取用户信息-需scope为snsapi-userinfo"><a href="#4-拉取用户信息-需scope为snsapi-userinfo" class="headerlink" title="4.拉取用户信息(需scope为snsapi_userinfo)"></a>4.拉取用户信息(需scope为snsapi_userinfo)</h2><p>注意scope，这里针对scope为 snsapi_userinfo 的情景，即需要获取用户openid以外的更多信息</p>
<h2 id="5-tips"><a href="#5-tips" class="headerlink" title="5.tips"></a>5.tips</h2><h3 id="获取url中code参数的方法"><a href="#获取url中code参数的方法" class="headerlink" title="获取url中code参数的方法"></a>获取url中code参数的方法</h3><ol>
<li>自写一个原生的<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getUrlParams (query, _url) &#123;</span><br><span class="line">  <span class="keyword">const</span> url = _url || <span class="built_in">window</span>.location.href</span><br><span class="line">  <span class="keyword">const</span> paramsString = url.indexOf(<span class="string">&#x27;?&#x27;</span>) &gt; -<span class="number">1</span> ? url.substring(url.indexOf(<span class="string">&#x27;?&#x27;</span>) + <span class="number">1</span>, url.length).split(<span class="string">&#x27;&amp;&#x27;</span>) : []</span><br><span class="line">  <span class="keyword">let</span> paramsObj = &#123;&#125;</span><br><span class="line">  paramsString.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    paramsObj[item.substring(<span class="number">0</span>, item.indexOf(<span class="string">&#x27;=&#x27;</span>))] = item.substring(item.indexOf(<span class="string">&#x27;=&#x27;</span>) + <span class="number">1</span>, item.length).split(<span class="string">&#x27;#&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(query).slice(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> paramsObj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> returnValue = paramsObj[query]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (returnValue) === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> returnValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>vue 中的 router相关方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$route.query.code</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="存储相关配置参数的位置"><a href="#存储相关配置参数的位置" class="headerlink" title="存储相关配置参数的位置"></a>存储相关配置参数的位置</h3><p>微信和支付宝授权啊支付啊什么的都需要传一些参数给支付宝或微信的后台，就前端来说，常见的如下</p>
<blockquote>
<p>appid scope redirect_uri 等<br>那这些固定的常量都写在哪里呢？之前我会单新建一个config文件夹，然后分别创建微信和支付宝所需要用到的配置文件，不过有时候在测试的时候不想一遍遍的请求微信那边的授权（比如我只是想那个openid请求自己应用的接口），所以会额外加一些已知的openid userinfo 等，这些往往会再加多两个文件，而且还要加多一些有关开发和生产环境的判断等等</p>
</blockquote>
<p>所以如果是在vue-cli的开发环境下，推荐使用<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F">环境变量和模式</a></p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ol>
<li><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html">微信官方文档-网页授权</a></li>
<li><a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F">vue-cli环境变量和模式</a></li>
</ol>
]]></content>
      <tags>
        <tag>WeChat</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 prettier + eslint 统一代码风格和语法检查</title>
    <url>/2020/07/03/%E4%BD%BF%E7%94%A8-prettier-eslint-%E7%BB%9F%E4%B8%80%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%92%8C%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<p>考虑各项目间的统一，使用 prettier 进行项目的代码风格格式化，使用 eslint 做语法检查，具体规范如下</p>
<span id="more"></span>

<h1 id="Prettier-vs-Linters"><a href="#Prettier-vs-Linters" class="headerlink" title="Prettier vs. Linters"></a>Prettier vs. Linters</h1><p>首先说明 Prettier 和 .Linters(ESLint/TSLint/stylelint, etc)的区别，</p>
<ol>
<li>Prettier 专注于代码风格上的统一，其配置项较少，是个 Opinionated formatter (就是类似 angular 那种，必须按照它自定的规则来)，</li>
<li>比如说 ESLint，它其实包括了代码风格规范和语法检查两部分，有众多的规范插件可供选择，其配置项也较为复杂。但在代码风格上，它只能提供异常报错的警示信息，不能直接帮我们输出风格统一的代码。</li>
</ol>
<blockquote>
<p><a href="https://prettier.io/docs/en/comparison.html">How does it compare to ESLint/TSLint/stylelint, etc.?</a></p>
</blockquote>
<h1 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h1><p>代码美化部分大致包含：触发自动换行的字符数，强制关键词前后加空格</p>
<p>prettier 的大部分规则都是不可配置了，只保留了几个争议特别大的规则给用户配置，比如单引号和双引号的选择，也正因如此，对团队的代码风格上的统一也会更有帮助</p>
<h2 id="风格规范"><a href="#风格规范" class="headerlink" title="风格规范"></a>风格规范</h2><p>直接执行如下命令查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx prettier --write .</span><br><span class="line">npx prettier --write app/</span><br><span class="line">npx prettier --write app/components/Button.js</span><br><span class="line">npx prettier --write app/**/*.test.js</span><br></pre></td></tr></table></figure>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>使用 <code>eslint-config-prettier</code> 覆盖掉 ESLint 的代码风格规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev eslint-config-prettier</span><br></pre></td></tr></table></figure>

<p>向根目录下 .eslintrc 文件中的 <strong>extend</strong> 增加 <code>&quot;prettier&quot;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;some-other-config-you-use&quot;</span>,</span><br><span class="line">    <span class="string">&quot;prettier&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置根目录下 .prettierrc 文件如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;eslintIntegration&quot;</span>: <span class="literal">true</span>, <span class="comment">//</span></span><br><span class="line">    <span class="attr">&quot;stylelintIntegration&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;tabWidth&quot;</span>: <span class="number">2</span>,        <span class="comment">// 缩进字符</span></span><br><span class="line">    <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,  <span class="comment">// 要不要单引号</span></span><br><span class="line">    <span class="attr">&quot;semi&quot;</span>: <span class="literal">false</span>         <span class="comment">// 要不要使用 ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置保存自动格式化，在用户的 <code>setting.json</code> 文件中加上如下配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;eslint.format.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## others ##</span><br><span class="line"></span><br><span class="line">### git hook ###</span><br><span class="line"></span><br><span class="line">如有需要忽略代码风格</span><br><span class="line"></span><br><span class="line">使用 husky 和 lint-staged 来确保每次提交前代码已是格式化后的状态，配置参考如下</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;**/*&quot;</span>: [<span class="string">&quot;eslint --fix&quot;</span>, <span class="string">&quot;prettier --write&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="about"><a href="#about" class="headerlink" title="about"></a>about</h2><ol>
<li><a href="https://prettier.io/docs/en/index.html">Prettier</a></li>
<li><a href="https://github.com/okonet/lint-staged#readme">lint-staged</a></li>
<li><a href="https://github.com/typicode/husky#readme">husky</a></li>
</ol>
<h1 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h1><p>语法检查部分大致包含：变量检查（重复引用，引入但未使用，声明但未使用。。。），无意义的bind</p>
<p>一般情况下，脚手架都自带了基础的 eslint 配置，所以主要还是注意eslint 的 plugin 的安装配置，参考如下</p>
<h2 id="about-1"><a href="#about-1" class="headerlink" title="about"></a>about</h2><ol>
<li><a href="https://eslint.org/docs/user-guide/getting-started">eslint</a></li>
<li><a href="https://eslint.org/docs/developer-guide/working-with-plugins">working-with-plugins</a></li>
</ol>
]]></content>
      <categories>
        <category>standard</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>IDE</tag>
        <tag>standard</tag>
      </tags>
  </entry>
  <entry>
    <title>手写一个Promise</title>
    <url>/2020/08/19/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAPromise/</url>
    <content><![CDATA[<p>尝试实现一个符合规范的 promise，含大量注释和新得～</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="built_in">require</span>(<span class="string">&#x27;console&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promisePractice = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">12</span>)</span><br><span class="line">  &#125;, <span class="number">4000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promisePractice</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区分 resolve() 和 reject() 方法传入的值是 promise 和 then() 方法的返回值 是 promise 的情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;PENDING&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULLFILLED = <span class="string">&#x27;FULLFILLED&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">fun</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 状态初始化</span></span><br><span class="line">    <span class="built_in">this</span>._status = PENDING</span><br><span class="line">    <span class="comment">// value</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 添加成功回调函数队列</span></span><br><span class="line">    <span class="built_in">this</span>._fullfilledQueues = []</span><br><span class="line">    <span class="comment">// 添加失败回调函数队列</span></span><br><span class="line">    <span class="built_in">this</span>._rejectedQueues = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> v !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;must accept a function as a parameter&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fun(<span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="built_in">this</span>._reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_resolve</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runFullfilled = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb</span><br><span class="line">        <span class="keyword">while</span> ((cb = <span class="built_in">this</span>._fullfilledQueues.shift())) &#123;</span><br><span class="line">          cb(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runrejected = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb</span><br><span class="line">        <span class="keyword">while</span> ((cb = <span class="built_in">this</span>._rejectedQueues.shift())) &#123;</span><br><span class="line">          cb(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (val <span class="keyword">instanceof</span> PromiseClass) &#123;</span><br><span class="line">        val.then(</span><br><span class="line">          <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._value = value</span><br><span class="line">            <span class="built_in">this</span>._status = FULLFILLED</span><br><span class="line">            runFullfilled(value)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._value = err</span><br><span class="line">            <span class="built_in">this</span>._status = REJECTED</span><br><span class="line">            runrejected(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = val</span><br><span class="line">        <span class="built_in">this</span>._status = FULLFILLED</span><br><span class="line">        runFullfilled(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setTimeout(run,0)</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> run(), <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_reject</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>._status = REJECTED</span><br><span class="line">    <span class="built_in">this</span>._value = err</span><br><span class="line">    <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> cb</span><br><span class="line">      <span class="keyword">while</span> ((cb = <span class="built_in">this</span>._rejectedQueues.shift())) &#123;</span><br><span class="line">        cb(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// setTimeout(run,0)</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> run(), <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then 方法必定返回一个 promise</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFullfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; _status, _value &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseClass(<span class="function">(<span class="params">onFullfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 封装成功时的回调函数</span></span><br><span class="line">      <span class="keyword">let</span> fullfilled = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onFullfilled !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            onFullfilledNext(value)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onFullfilled(value)</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> PromiseClass) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFullfilledNext, onRejectedNext)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 否则会将返回结果直接作为参数，传入下一个then的Fulfilled回调函数，并立即执行下一个then的Fulfilled回调函数</span></span><br><span class="line">              onFullfilledNext(res)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          onRejectedNext(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 封装失败时的回调函数</span></span><br><span class="line">      <span class="keyword">let</span> rejected = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            onRejectedNext(err)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onRejected(err)</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> PromiseClass) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFullfilledNext, onRejectedNext)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 否则会将返回结果直接作为参数，传入下一个then的rejected回调函数，并立即执行下一个then的rejected回调函数</span></span><br><span class="line">              onRejectedNext(res)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          onRejectedNext(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="built_in">this</span>._fullfilledQueues.push(onFullfilled)</span><br><span class="line">          <span class="built_in">this</span>._rejectedQueues.push(onRejected)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FULLFILLED:</span><br><span class="line">          fullfilled(_value)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejected(_value)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(reject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, reject)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val <span class="keyword">instanceof</span> PromiseClass) &#123;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PromiseClass(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(val)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseClass(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseClass(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> values = []</span><br><span class="line">      count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [index, promise] <span class="keyword">of</span> list.entires()) &#123;</span><br><span class="line">        <span class="comment">// 确保数组中的各项是 PromiseClass的实例，先调用 PromiseClass.resolve</span></span><br><span class="line">        <span class="built_in">this</span>.resolve(promise).then(</span><br><span class="line">          <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            values[index] = res</span><br><span class="line">            count++</span><br><span class="line">            <span class="comment">// 所有状态都为 fullfilled 时返回的PromiseClass状态变成 fullfilled</span></span><br><span class="line">            <span class="keyword">if</span> (count === list.length) resolve(values)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 有一个被rejected时返回的MyPromise状态就变成rejected</span></span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseClass(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resolve(p).then(</span><br><span class="line">          <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">finally</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">      <span class="function">(<span class="params">value</span>) =&gt;</span> PromiseClass.resolve(cb()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">      <span class="function">(<span class="params">reason</span>) =&gt;</span></span><br><span class="line">        PromiseClass.resolve(cb()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>样式规范(一)</title>
    <url>/2017/03/14/%E6%A0%B7%E5%BC%8F%E8%A7%84%E8%8C%83-%E4%B8%80/</url>
    <content><![CDATA[<p>为提高开发效率，特定了一些规范</p>
<span id="more"></span>
<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><blockquote>
<p><a href="">github</a><br>需要以下几点的储备</p>
</blockquote>
<p>1.less<br>2.媒体查询<br>3.before和after<br>4.熟练的掌握css的选择器<br>5.查询条件一栏间距可以写死</p>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><blockquote>
<p>这里用来记一下</p>
</blockquote>
<h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>xxs，xs，sm，空，md，lg，xl，xxl</p>
<blockquote>
<p>size,你懂的</p>
</blockquote>
<p>还有，full</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>top，bottom，left，right，middle</p>
<h1 id="自适应-媒体查询"><a href="#自适应-媒体查询" class="headerlink" title="自适应(媒体查询)"></a>自适应(媒体查询)</h1><h2 id="范围在此"><a href="#范围在此" class="headerlink" title="范围在此"></a>范围在此</h2><h1 id="less部分用到的函数"><a href="#less部分用到的函数" class="headerlink" title="less部分用到的函数"></a>less部分用到的函数</h1><h2 id="lighten和darken"><a href="#lighten和darken" class="headerlink" title="lighten和darken"></a>lighten和darken</h2><blockquote>
<p>提高／降低颜色的亮度</p>
</blockquote>
<p>HSL即色相、饱和度、亮度</p>
<ul>
<li>色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。</li>
<li>饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取0-100%的数值。</li>
<li>明度（V），亮度（L），取0-100%。<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3>lighten(color,percent)；</li>
</ul>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>医学影像入门</title>
    <url>/2021/07/14/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>最近在搞 dicom 文件的渲染</p>
<h2 id="相关工具库概述"><a href="#相关工具库概述" class="headerlink" title="相关工具库概述"></a>相关工具库概述</h2><ul>
<li>**<a href="#cornerstone">cornerstone(core)</a>**，核心库，解析 imageId，加载 imageLoader，渲染图片，是以下库的基石。<ul>
<li>**<a href="#imageLoader">image loader</a>**，图片加载器，资源会经由 loader 返回 imageId</li>
</ul>
</li>
<li>**<a href="#cornerstoneTools">cornerstoneTools</a>**，工具库，提供常用的交互工具（缩放，对比度亮度调整，播放帧等等等），可在此基础上开发更高级的工具</li>
<li>**<a href="#dicomParser">dicomParser</a>**，用以解析 DICOM 文件，获取图片以外的相关信息，比如患者名，影像帧数，等等。具体类目信息见 <a href="https://www.dicomlibrary.com/dicom/dicom-tags/">tag</a></li>
<li>**<a href="#cornerstoneMath">cornerstoneMath</a>**，数学和几何计算用到的库</li>
<li>**<a href="https://ohif.org/">OHIF</a>**，开放医学影像基金会，在 cornerstone 和 tool 的基础上开发了 react 版本的组件</li>
<li>**<a href="">OHIF viewer</a>**，</li>
<li>**<a href="">OHIF tracker</a>**，</li>
</ul>
<h2 id="cornerstone"><a href="#cornerstone" class="headerlink" title="cornerstone"></a>cornerstone</h2><ul>
<li><a href="https://docs.cornerstonejs.org/">文档</a></li>
<li><a href="https://harrychen0506.github.io/cornerstone-analysis/core/concepts/images.html">中文文档（非官方）</a></li>
<li><a href="https://docs.cornerstonejs.org/">github</a></li>
<li><a href="https://rawgit.com/cornerstonejs/cornerstone/master/example/index.html">examples</a> - <a href="https://github.com/cornerstonejs/cornerstone/tree/master/example">code</a></li>
</ul>
<h2 id="cornerstoneTools"><a href="#cornerstoneTools" class="headerlink" title="cornerstoneTools"></a>cornerstoneTools</h2><ul>
<li><a href="https://tools.cornerstonejs.org/">文档</a></li>
<li><a href="https://github.com/cornerstonejs/cornerstoneTools">github</a></li>
<li><a href="https://tools.cornerstonejs.org/examples/">examples</a> - <a href="https://github.com/cornerstonejs/cornerstone/tree/master/example">code</a></li>
</ul>
<h3 id="imageLoader"><a href="#imageLoader" class="headerlink" title="imageLoader"></a>imageLoader</h3><h4 id="Cornerstone-WADO-image-loader"><a href="#Cornerstone-WADO-image-loader" class="headerlink" title="Cornerstone WADO image loader"></a>Cornerstone WADO image loader</h4><ul>
<li><a href="https://github.com/cornerstonejs/cornerstoneWADOImageLoader">github</a></li>
</ul>
<h4 id="Cornerstone-Web-image-loader"><a href="#Cornerstone-Web-image-loader" class="headerlink" title="Cornerstone Web image loader"></a>Cornerstone Web image loader</h4><p>此 loader 用来加载 web 图片，比如，png，jpeg 格式的图片</p>
<ul>
<li><a href="https://github.com/cornerstonejs/cornerstoneWebImageLoader">github</a></li>
<li><a href="https://rawgit.com/cornerstonejs/cornerstoneWebImageLoader/master/examples/index.html">examples</a></li>
</ul>
<h2 id="dicomParser"><a href="#dicomParser" class="headerlink" title="dicomParser"></a>dicomParser</h2><ul>
<li><a href="https://github.com/cornerstonejs/dicomParser">github</a></li>
<li><a href="https://rawgit.com/cornerstonejs/dicomParser/master/examples/index.html">examples</a></li>
<li><a href="https://www.dicomlibrary.com/dicom/dicom-tags/">tag</a></li>
</ul>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>很多时候需要根据 tag 值拿到对应的信息，推荐一个 <a href="https://github.com/smikitky/vscode-dicom-dump">vscode 插件</a></p>
<h2 id="cornerstoneMath"><a href="#cornerstoneMath" class="headerlink" title="cornerstoneMath"></a>cornerstoneMath</h2><ul>
<li><a href="https://github.com/cornerstonejs/cornerstoneMath">github</a></li>
</ul>
<h2 id="OHIF-viewer"><a href="#OHIF-viewer" class="headerlink" title="OHIF viewer"></a>OHIF viewer</h2><ul>
<li><a href="https://docs.ohif.org/">文档</a></li>
<li><a href="https://github.com/cornerstonejs/cornerstoneMath">github</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>浏览器渲染过程</title>
    <url>/2017/05/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>暂时只是大概读了一遍，先记下来</p>
<h1 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h1><p>自上而下</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ul>
<p>前四层构成TCP/IP协议族，之所以分层，我觉得可以理解为像前端的模块化，易于管理，改动。实际上设计也变得简单，各层只需考虑自己分内的事</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层决定了向用户提供应用服务时通信的活动。</p>
<blockquote>
<p>包含FTP，DNS，HTTP</p>
</blockquote>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。</p>
<blockquote>
<p>包含TCP，UDP(用户数据报协议)</p>
</blockquote>
<h2 id="网络层-网络互连层"><a href="#网络层-网络互连层" class="headerlink" title="网络层(网络互连层)"></a>网络层(网络互连层)</h2><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p>
<blockquote>
<p>IP</p>
</blockquote>
<h2 id="链路层-数据链路层-网络接口层"><a href="#链路层-数据链路层-网络接口层" class="headerlink" title="链路层(数据链路层)(网络接口层)"></a>链路层(数据链路层)(网络接口层)</h2><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。</p>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h2><p>生成针对目标服务器的HTTP请求报文</p>
<h1 id="从输入-URL-到页面加载完成的过程中都发生了什么事情？"><a href="#从输入-URL-到页面加载完成的过程中都发生了什么事情？" class="headerlink" title="从输入 URL 到页面加载完成的过程中都发生了什么事情？"></a>从输入 URL 到页面加载完成的过程中都发生了什么事情？</h1><ul>
<li>输入URL </li>
<li>发起请求：URL解析/DNS解析  </li>
<li>网络连接：三次握手  </li>
<li>服务器响应请求：返回数据  </li>
<li>客户端接收响应：浏览器加载/渲染页面</li>
</ul>
<h1 id="两个引擎"><a href="#两个引擎" class="headerlink" title="两个引擎"></a>两个引擎</h1><p>浏览器两个引擎</p>
<ol>
<li><p>渲染引擎</p>
<blockquote>
<p>常称为浏览器的内核，webkit，gecko，persto(opera)</p>
</blockquote>
</li>
<li><p>js引擎</p>
</li>
</ol>
<h1 id="两个树"><a href="#两个树" class="headerlink" title="两个树"></a>两个树</h1><h1 id="遇到的一些问题和解决办法"><a href="#遇到的一些问题和解决办法" class="headerlink" title="遇到的一些问题和解决办法"></a>遇到的一些问题和解决办法</h1><h2 id="Unchecked-runtime-lastError-The-message-port-closed-before-a-response-was-received"><a href="#Unchecked-runtime-lastError-The-message-port-closed-before-a-response-was-received" class="headerlink" title="Unchecked runtime.lastError: The message port closed before a response was received."></a>Unchecked runtime.lastError: The message port closed before a response was received.</h2><p>调试工具中报如上的错误，查阅资料得知是chrome某个插件报的错，自己一一验证，发祥是迅雷下载插件这个毒瘤，禁用可消除如上的报错</p>
<blockquote>
<p><a href="http://coolshell.cn/articles/9666.html">浏览器的渲染原理简介</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.jianshu.com/p/e141d1543143">简书，浏览器加载解析渲染</a></p>
</blockquote>
<blockquote>
<p>图解http</p>
</blockquote>
]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈自己对Promise的理解</title>
    <url>/2017/08/03/%E6%B5%85%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9Promise%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>一直以来虽然写了不少promise，总感觉有点一知半解，现在花些时间整理下。</p>
<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><p>自己最早是从一篇介绍promise的文章看到的，记得文章中说promise可以使代码更整洁，避免陷入重重的回调当中。之后真正写是从angularjs中的$http服务中开始的，嗯，其中的写法很多，我一直用success和error来加载回调函数，现在看起来应该是then和catch的实现(或者是只用then方法即then中含有两个方法参数)，还有bootstrap UI for Angular组件中modal框部分，$modal.open().result返回的便是一个promise对象，在上面写关闭modal框后实现的方法</p>
<p>等等，现在又接触到angular2的observer了，</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><blockquote>
<p><a href="http://liubin.org/promises-book/#promises-overview">promise小小书</a></p>
</blockquote>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>创建promise对象的流程如下所示。</p>
<ol>
<li><p>new Promise(fn) 返回一个promise对象</p>
</li>
<li><p>在fn 中指定异步等处理</p>
</li>
<li><p>处理结果正常的话，调用resolve(处理结果值)</p>
</li>
<li><p>处理结果错误的话，调用reject(Error对象)</p>
</li>
</ol>
<p>举个书上的栗子，一看便懂</p>
<pre><code>function getURL(URL) &#123;
    return new Promise(function (resolve, reject) &#123;
        var req = new XMLHttpRequest();
        req.open(&#39;GET&#39;, URL, true);
        req.onload = function () &#123;
            if (req.status === 200) &#123;
                resolve(req.responseText);
            &#125; else &#123;
                reject(new Error(req.statusText));
            &#125;
        &#125;;
        req.onerror = function () &#123;
            reject(new Error(req.statusText));
        &#125;;
        req.send();
    &#125;);
&#125;
// 运行示例
var URL = &quot;http://httpbin.org/get&quot;;
getURL(URL).then(function onFulfilled(value)&#123;
    console.log(value);
&#125;).catch(function onRejected(error)&#123;
    console.error(error);
&#125;);
</code></pre>
<p>首先，返回resolve就代表着接下来then的回调函数会调用，(也意味着catch中的回调函数不会执行了)</p>
<p>这有个angular2的例子，是个resolve很好的应用</p>
<pre><code>//返回的promise中的泛型，为返回data的格式
queryLoans(query:any):Promise&lt;&#123;count:number,items:Loan[]&#125;&gt;&#123;
    return this.myHttp.get(&#123;
      api:this.myHttp.api.loanList,
      query:query
    &#125;).toPromise()
      .then((res)=&gt;&#123;
        let data=&#123;
          count:0,
          items:[]
        &#125;;
        if(res.ok)&#123;
          console.log(res);
          let result=res.json();
          if(result.status===200)&#123;
            data.count=result.body.paginator.totalCount;
            for(let l of result.body.records)&#123;
              let loan=new Loan();
              loan.borrowApplyId=l.borrowApplyId;
              loan.memberId=l.memberId;
              loan.companyName=l.companyName;
              loan.applyAmount=parseFloat(l.applyAmount);
              loan.approveAmount=parseFloat(l.approveAmount);
              loan.productId=l.productId;
              loan.borrowHowLong=l.borrowHowlong;
              loan.repaymentWay=l.repaymentWay;
              loan.cardId=l.cardId;
              loan.cardNo=l.cardNo;
              loan.isContract=!!parseFloat(l.isContract);
              loan.status=parseFloat(l.status);
              loan.createTime=l.createTime;
              loan.auditOneTime=l.auditOneTime;
              loan.auditOneBy=l.auditOneBy;
              data.items.push(loan);
            &#125;
          &#125;
        &#125;
        return Promise.resolve(data);
      &#125;);
&#125;
</code></pre>
<p>angular2使用typescript来写的，ts可以说是强类型了，这个方法是用来获取接口的数据，并对接收的数据进行了一定的格式化，最后把格式化后的数据放在promise中的resolve中返回，angular2中这种和数据打交道的方法一般都放置在服务中，组件作为服务的最大消费者来调用它。</p>
<h2 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h2><p>实例化的promise对象只有三种状态，成功，失败，初始化状态</p>
<ul>
<li><p>“has-resolution” - Fulfilled<br>resolve(成功)时。此时会调用 onFulfilled</p>
</li>
<li><p>“has-rejection” - Rejected<br>reject(失败)时。此时会调用 onRejected</p>
</li>
<li><p>“unresolved” - Pending<br>既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等</p>
</li>
</ul>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>Promise.all 接收一个 promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 .then 方法。</p>
<pre><code>Promise.all([promise1,promise2],...).then(res=&gt;&#123;&#125;)
</code></pre>
<p>res接收各个结果组成的数组，</p>
<p>个人觉得这个会应用于接口间顺序的请求渲染，比如编辑页面的初始渲染可能会依赖于一些字典接口查询后的结果。或者对多个接口数据请求后的统一处理。</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p>Promise.race 也同样接收一个promise对象的数组作为参数，区别是Promise.race只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理</p>
<blockquote>
<p>这样的话，之后的then或catch接收的参数就只有最快进入FulFilled 或 Rejected 状态的promise返回的数据了</p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习-口语篇</title>
    <url>/2018/11/05/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0-%E5%8F%A3%E8%AF%AD%E7%AF%87/</url>
    <content><![CDATA[<p>今年集中学习了一段时间英语，后经我家东贤提醒，应该写写自己学习的心得，供我们以后参考。</p>
<span id="more"></span>

<h1 id="音标"><a href="#音标" class="headerlink" title="音标"></a>音标</h1><p>既然是口语相关，音标自然是基础啦，推荐 <strong>赖世雄美语音标</strong>，分音频和文本部分，连接如下</p>
<ul>
<li><a href="https://www.ximalaya.com/waiyu/4324892/">音频-喜马拉雅</a></li>
<li><a href="https://pan.baidu.com/s/1yBUD_d8Y3EVh_eYm_WS8Hg">文本-提取码12na</a></li>
</ul>
<h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><p>单词量是基础，这个没啥说的，找个app大声跟着读吧</p>
<h1 id="听和看"><a href="#听和看" class="headerlink" title="听和看"></a>听和看</h1><p>我觉得对语言来讲，各方面的能力都是协同进步的，所以口语也定然离不开听力阅读等部分，听和看的同时要加上模仿和思考，这里给出相关推荐</p>
<h2 id="听"><a href="#听" class="headerlink" title="听"></a>听</h2><p>我觉得VOA系列就很棒，<strong>VOA-special</strong> 现在有自己的发音评测，其他的之后在听力篇写写</p>
<h2 id="看"><a href="#看" class="headerlink" title="看"></a>看</h2><ul>
<li><p><strong>How I Met Your Mother</strong>，美剧，几个人在一起唠嗑，包含了大量日常的俚语，而且还蛮有趣的哈哈，建议把台词打印下来，可以模仿某个人的对话找找感觉</p>
</li>
<li><p><strong>老友记</strong>，这个我没看过啦，听说有蛮多相关APP的，资源应该很丰富 </p>
</li>
<li><p><strong>charlotte’s web</strong>，英文儿童读物，老师推荐 </p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1PhC1Gp4yxNRZYT9F_gRGFQ">文本-提取码204a</a></p>
</blockquote>
</li>
</ul>
<h1 id="连读部分"><a href="#连读部分" class="headerlink" title="连读部分"></a>连读部分</h1><p>感觉这个是进阶的重要部分，一个知乎话题供参考</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/35857073">知乎-怎样解决英语的连读吞音等问题</a></p>
</blockquote>
<p>有看到推荐<strong>A Course in Phonetics</strong>，瞅了一下觉得应该靠谱，便去搜了下相关资源</p>
<ul>
<li><a href="https://pan.baidu.com/s/1qR0b_P1FPIO4xsA3dNMZfQ">文本-提取码59dp</a></li>
<li><a href="https://corpus.linguistics.berkeley.edu/acip/course/chapter1/">示例音频及作业</a></li>
<li><a href="http://ocw.aca.ntu.edu.tw/ntu-ocw/index.php/ocw/cou/101S102">台大公开课</a></li>
</ul>
<h1 id="讲"><a href="#讲" class="headerlink" title="讲"></a>讲</h1><p>很多时候我们说英文的话都是先想象中文怎样表达，然后再转换成英文，这个过程的长短就是区分初学者水平的关键，不过熟练的话可能根本没有转英文这一步，直接英文怼上去哈。这就要求多想多讲啦，练习可以分如下几个方面</p>
<ul>
<li><strong>话题练习</strong>，就是雅思和托福口语部分的练习，多瞅瞅相关真题，蛮多APP的，我用的小站</li>
<li><strong>多讲多讲</strong>，交流多用用英文啦，不过一般情况下用到英文对地方太少啦，建议每次讲完话多用英文对语境下思考下英文版对回答</li>
<li><strong>纠错</strong>，能多和英文老师交流最好啦，网上也有相关外教口语方面的授课。还有就是很多APP有自己的录音上传评分功能，大部分还是蛮准的，可以的话自己录音反复和原文对比</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.zhihu.com/question/20097263">知乎-怎么练好英语口语</a><br><a href="https://www.zhihu.com/question/35857073">知乎-怎样解决英语的连读吞音等问题</a><br>啊，泣不成声啊</p>
</blockquote>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>账户系统前端小规范</title>
    <url>/2017/01/10/%E8%B4%A6%E6%88%B7%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AB%AF%E5%B0%8F%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>为了后来的开发维护方便，在此写下账户系统前端部分的概述，包括所用框架，依赖，管理工具，命名规范，项目结构等，后面有时间也会总结下前端开发的规范。</p>
<h1 id="所用框架"><a href="#所用框架" class="headerlink" title="所用框架"></a>所用框架</h1><p>系统所用框架为angular1.3版本，为2016年之前主流版本，前端这几年涌现了太多框架，自己熟悉了这个版本后也要跟上时代的步伐，学习angular2等</p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>angular参照Java搞出了依赖注入和指令，系统的依赖注入和个部分功能解释如下</p>
<h2 id="ui-router"><a href="#ui-router" class="headerlink" title="ui-router"></a>ui-router</h2><p>angular1.x 本身有ng-router，但是满足不了复杂的应用，系统采用的<br>依赖为ui-router，ui-router具体用法配置和其自带的指令会单独讲一下。</p>
<h1 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h1><p>包管理工具用了gulp，主要执行如下功能</p>
<h2 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h2><h2 id="js压缩"><a href="#js压缩" class="headerlink" title="js压缩"></a>js压缩</h2><blockquote>
<p>注意，为了避免压缩时注入的部分被误识别为变量部分，从而导致替换，应写成数组格式的依赖注入，特别是系统采用的angular-ui的modal服务，在实例化时也要写成数组格式的注入，分别如下</p>
</blockquote>
<p>1.控制器初始化</p>
<pre><code> var appModule=angular.module(&quot;app&quot;,[])
     appModule.controller(&quot;controllerName&quot;,
                 [&quot;dev1&quot;,&quot;dev2&quot;,function(dev1,dev2)&#123;
   //controller body here
&#125;])
</code></pre>
<p>2.举例modal模态框的</p>
<pre><code> var modalInstance =$modal.open(&#123;
//配置部分,只显示modal控制器配置，我懒
controller:modalController
&#125;)
//by the way 这里可以写modalInstance的promise
//初始化modal的控制器，采用数组格式的依赖注入
var modalController =[&quot;dev1&quot;,&quot;dev2&quot;,function(dev1,dev2)&#123;
&#125;]
</code></pre>
<blockquote>
<p>扯远了，那个modal的作用域独立，要resolve进来数据或方法</p>
</blockquote>
<h2 id="去注释去空格"><a href="#去注释去空格" class="headerlink" title="去注释去空格"></a>去注释去空格</h2><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><blockquote>
<p>这里只针对本系统给出一定的规范</p>
</blockquote>
<p>控制器js文件和模板html名字相同，参照ui-router的命名结构，并相应的将点替换为下短横,ui-sref指令的值命名如下<br>在如总模板页为app,其下的一级菜单为app.Level1NavName,一级菜单下的二级菜单为app.Level1NavName.level2NavName,可参考config.router.js文件的配置，三级相同命名。<br>相应的文件命名Level1NavName_level2NavName.js/html</p>
<blockquote>
<p>其中Level1NavName和Level2NavName全系统唯一，注意路由配置的url属性，表现为URL层级</p>
</blockquote>
<p>madal弹出框的templete命名为触发事件函数的名称，controller属性的名称命名为函数名加Ctrl，例如</p>
<pre><code> $scope.appRegisterEdit=function(row)&#123;
   var myrow=row.entity;
   console.log(myrow);
   var modalInstance = $modal.open(&#123;
   templateUrl: &#39;appRegisterEdit.html&#39;,
   controller: appRegisterEditCtrl,
   resolve: &#123;
    items: function () &#123;
      return myrow;
    &#125;,
    shuaxing: function()&#123;
      return $scope.shuaxing;
    &#125;,
    pop:function()&#123;
      return $scope.pop;
    &#125;
   &#125;
 &#125;);
    modalInstance.result.then(function () &#123;
&#125;, function () &#123;
  $scope.shuaxing();
&#125;);
&#125;
</code></pre>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>译-8个有用的scss最佳实践</title>
    <url>/2020/08/19/%E8%AF%91-8%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84scss%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>原文地址：<a href="https://dev.to/liaowow/8-css-best-practices-to-keep-in-mind-4n5h">8 SCSS Best Practices to Keep in Mind</a></li>
<li>原文作者：<a href="https://github.com/liaowow">Annie Liao</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/article/2020/8-scss-best-practices-to-keep-in-mind.md">https://github.com/xitu/gold-miner/blob/master/article/2020/8-scss-best-practices-to-keep-in-mind.md</a></li>
<li>译者：<a href="https://github.com/snowyYU">snowyYU</a></li>
<li>校对者：<a href="https://github.com/onlinelei">onlinelei</a>，<a href="https://github.com/iceytea">iceytea</a></li>
</ul>
</blockquote>
<h1 id="8-个有用的-SCSS-最佳实践"><a href="#8-个有用的-SCSS-最佳实践" class="headerlink" title="8 个有用的 SCSS 最佳实践"></a>8 个有用的 SCSS 最佳实践</h1><p>上周我看了一家公司的代码规范，我发现其中一些规则同样适用于个人项目的开发。</p>
<p>我觉得以下的 8 个最佳实践特别棒：</p>
<h2 id="1-移动端优先"><a href="#1-移动端优先" class="headerlink" title="1. 移动端优先"></a>1. 移动端优先</h2><p>做响应式项目的时候，一般会先写 PC 版本的样式，但这会使移动端样式的书写变得特别痛苦。因此，我们应该先进行移动端样式的书写，在移动端样式的基础上向 PC 端的样式拓展。</p>
<p>不要这样做:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bad</span> &#123;</span><br><span class="line">  <span class="comment">// Desktop code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="comment">// Mobile code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该这样做:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.good</span> &#123;</span><br><span class="line">  <span class="comment">// Mobile code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="comment">// Desktop code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-提前定义好变量"><a href="#2-提前定义好变量" class="headerlink" title="2. 提前定义好变量"></a>2. 提前定义好变量</h2><p>初始化项目中，要先定义 CSS 变量和 mixins，这样可以提升项目的可维护性。</p>
<p>规范中提到，以下这些属性会经常读取 CSS 变量：</p>
<ul>
<li><code>border-radius</code></li>
<li><code>color</code></li>
<li><code>font-family</code></li>
<li><code>font-weight</code></li>
<li><code>margin</code> (间隔, 常见网格布局的间隔)</li>
<li><code>transition</code> (持续时间, easing) – 建议用 mixin</li>
</ul>
<h2 id="3-不要使用-id-和-important"><a href="#3-不要使用-id-和-important" class="headerlink" title="3. 不要使用 #id 和 !important"></a>3. 不要使用 <code>#id</code> 和 <code>!important</code></h2><p><code>!important</code> 和 <code>#id</code> 这俩太霸道啦，经常会搞乱 CSS 渲染的顺序和展示的优先级，在团队开发中尤甚。</p>
<p>不要这样做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#bad</span> &#123;</span><br><span class="line">  <span class="selector-id">#worse</span> &#123;</span><br><span class="line">     <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该这样做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.good</span> &#123;</span><br><span class="line">  <span class="selector-class">.better</span> &#123;</span><br><span class="line">     <span class="attribute">background-color</span>: rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-不要写具体的数值"><a href="#4-不要写具体的数值" class="headerlink" title="4. 不要写具体的数值"></a>4. 不要写具体的数值</h2><p>写样式的时候尽量不要给属性设置具体的数值，从页面渲染的结果上来看，它可能 “恰好合适”；但是其他开发人员可能不理解为什么必须将属性设置为这种特定的数字。因此，尽量写一些有含义的表达式或者计算式来使此处的可读性更高。</p>
<p>有兴趣的话， 在 CSS Tricks 上有一个 <a href="https://css-tricks.com/magic-numbers-in-css/">说明</a> 指出了使用具体数值的坏处。</p>
<p>不要这样做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bad</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该这样做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.good</span> &#123;</span><br><span class="line">  <span class="comment">// 20px because of font height</span></span><br><span class="line">  <span class="attribute">left</span>: (<span class="variable">$GUTTER</span> - <span class="number">20px</span> - (<span class="variable">$NAV_HEIGHT</span> / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-描述性良好的命名"><a href="#5-描述性良好的命名" class="headerlink" title="5. 描述性良好的命名"></a>5. 描述性良好的命名</h2><p>很多人都是根据样式的显示结果来命名 CSS。 其实根据结构来命名更好。</p>
<p>不要这样做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.huge-font</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Impact&#x27;</span>, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.blue</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$COLOR_BLUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该这样做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.brand__title</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Impact&#x27;</span>, serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.u-highlight</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$COLOR_BLUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-值为-0-时的单位"><a href="#6-值为-0-时的单位" class="headerlink" title="6. 值为 0 时的单位"></a>6. 值为 0 时的单位</h2><p>可能根据别的规范和个人习惯的原因对本条有意见，不过为了说明规范对一个项目的重要性。下面这条规则要求你在持续时间为 0 时加上单位（这种情况常见于编写 CSS 动效时，如过渡效果 transition-duration，规定完成过渡效果需要花费的时间（以秒或毫秒计） ），不要为长度为 0 的值指定单位（这里指 width、height、top、margin、padding 等可度量尺寸、位置的属性）。此外，为小数位添加前导零，注意啊，小数位别太长啦，最好别超过三位。</p>
<p>不要这样做:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.not-so-good</span> &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: .<span class="number">4567</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该这样做:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.better</span> &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">0s</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-单行注释"><a href="#7-单行注释" class="headerlink" title="7. 单行注释"></a>7. 单行注释</h2><p>这里建议在所要描述属性的上一行添加注释。使用块级注释符 (<code>/* */</code>) 不利于注释的删除和取消，所以使用单行注释符 (<code>//</code>) 来替代它。</p>
<p>不要这样做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bad</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red; <span class="comment">// 没在属性的上方写注释</span></span><br><span class="line">  <span class="comment">/* padding-top: 30px;</span></span><br><span class="line"><span class="comment">  width: 100% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该这样做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.good</span> &#123;</span><br><span class="line">  <span class="comment">// 在属性的上方写注释</span></span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="comment">// padding-top: 30px;</span></span><br><span class="line">  <span class="comment">// width: 100%;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-嵌套媒体查询"><a href="#8-嵌套媒体查询" class="headerlink" title="8. 嵌套媒体查询"></a>8. 嵌套媒体查询</h2><p>为了方便的定位媒体查询的声明，不要将它们嵌套在每个选择器中，而是将它们放在本页最顶级 scss 选择器中。</p>
<p>不要这样做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bad</span> &#123;</span><br><span class="line"></span><br><span class="line">  &amp;__area &#123;</span><br><span class="line">    <span class="comment">// Code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">568px</span>) &#123;</span><br><span class="line">      <span class="comment">// Code</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;__section &#123;</span><br><span class="line">    <span class="comment">// Code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">568px</span>) &#123;</span><br><span class="line">      <span class="comment">// Code</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该这样做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.good</span> &#123;</span><br><span class="line"></span><br><span class="line">  &amp;__area &#123;</span><br><span class="line">    <span class="comment">// Code</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;__section &#123;</span><br><span class="line">    <span class="comment">// Code</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">568px</span>) &#123;</span><br><span class="line">    &amp;__area &#123;</span><br><span class="line">      <span class="comment">// Code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;__section &#123;</span><br><span class="line">      <span class="comment">// Code</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里虽然只有寥寥几条不尽详细的规范，但是它们在项目中可是相当重要的。如果你见到了觉得很棒棒的 CSS 规范准则，还请在评论区中分享出来！</p>
<blockquote>
<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、<a href="https://github.com/xitu/gold-miner#ios">iOS</a>、<a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、<a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、<a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、<a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p>
</blockquote>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>规范</tag>
        <tag>译文</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>进击的angular2</title>
    <url>/2017/07/21/%E8%BF%9B%E5%87%BB%E7%9A%84angular2/</url>
    <content><![CDATA[<p>记录下</p>
<span id="more"></span>

<p>angular2以上用了typescript开发，怎么说呢，也要学习下ts的语法，所以记录的问题分为两部分了。</p>
<h1 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h1><h2 id="资料部分"><a href="#资料部分" class="headerlink" title="资料部分"></a>资料部分</h2><blockquote>
<p>官网文档很重要</p>
</blockquote>
<ol>
<li><a href="https://www.tslang.cn/docs/home.html">ts中文官网</a>墙裂推荐</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h3><h3 id="对类中"><a href="#对类中" class="headerlink" title="对类中"></a>对类中</h3><h1 id="angular"><a href="#angular" class="headerlink" title="angular"></a>angular</h1><h2 id="资料部分-1"><a href="#资料部分-1" class="headerlink" title="资料部分"></a>资料部分</h2><ol>
<li><a href="https://angular.cn/">angular中文网</a>相当好，每个翻译都有对应的英文</li>
</ol>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><h3 id="service可以用作单例对象吗"><a href="#service可以用作单例对象吗" class="headerlink" title="service可以用作单例对象吗"></a>service可以用作单例对象吗</h3><p>angular中的service我觉得只是用injectable装饰器修饰的一个类，既然是类的话</p>
<blockquote>
<p><a href="http://www.zcfy.cc/article/javascript-design-patterns-the-singleton-918.html">JavaScript设计模式：单例模式</a></p>
</blockquote>
<blockquote>
<p><a href="http://liaodanqi.me/2017/03/24/design-pattern-singleton/">2</a></p>
</blockquote>
<h3 id="angular组件间的通信"><a href="#angular组件间的通信" class="headerlink" title="angular组件间的通信"></a>angular组件间的通信</h3><ol>
<li>通过单例的类，字变量对象，服务</li>
<li>通过router传参是个方法</li>
<li>@input和@output装饰器</li>
</ol>
<h2 id="资料部分-2"><a href="#资料部分-2" class="headerlink" title="资料部分"></a>资料部分</h2><blockquote>
<p>官方文档炒鸡重要啊</p>
</blockquote>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2>]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title>进击的vue</title>
    <url>/2017/06/20/%E8%BF%9B%E5%87%BB%E7%9A%84vue/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>配置husky与lint-staged用以实现快照生成前的代码检查和格式化</title>
    <url>/2020/12/08/%E9%85%8D%E7%BD%AEhusky%E4%B8%8Elint-staged%E7%94%A8%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%BF%AB%E7%85%A7%E7%94%9F%E6%88%90%E5%89%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<p>在之前的项目中，团队为了保持代码风格的统一会统一要求为各自的 vs-code 安装 <strong>prettier</strong> 插件，然后在项目中添加 <strong>.prettierrc</strong> 配置文件，还需要设置 vs-code 中的自动保存时使用 <strong>prettier</strong> 插件 格式化代码。同样为了减少低级的代码错误，也引进了 <strong>eslint</strong> 进行代码的检查。现引入 husky 和 lint-stage 来优化协作流程</p>
<span id="more"></span>

<p><strong>vue</strong> 项目在初始化的时候可以直接选择启用 <code>Lint and fix on commit</code>，如下</p>
<p><img src="http://ww1.sinaimg.cn/large/40c136bfgy1glgvu3ivx9j20v00caqf6.jpg" alt="WX20201208-234451@2x.png"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先安装 Eslint 和 Prettier </p>
<blockquote>
<p>如果原项目是小程序之类的没有 package.json 文件，需要先 <code>npm init</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install eslint --save-dev  </span><br></pre></td></tr></table></figure>

<p>配置下 eslint，新增 .eslintrc.js 和 .eslintignore 文件，配置如下</p>
<blockquote>
<p>如果需要支持 typescript，还需 <code>npm i -d @typescript-eslint/parser @typescript-eslint/eslint-plugin</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eslint.js  </span></span><br><span class="line"><span class="comment">// for ts //考虑到小程序初始化ts时已有的ts代码通过不了此配置下的校验，所以使用 ts 版本的 precommit 要慎重</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">parser</span>: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>, <span class="comment">//定义ESLint的解析器</span></span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;plugin:@typescript-eslint/recommended&#x27;</span>], <span class="comment">//定义文件继承的子规范</span></span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;@typescript-eslint&#x27;</span>], <span class="comment">//定义了该eslint文件所依赖的插件</span></span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="comment">//指定代码的运行环境</span></span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">commonjs</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">  <span class="comment">//全局变量</span></span><br><span class="line">  <span class="attr">globals</span>: &#123;</span><br><span class="line">    <span class="attr">__DEV__</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">__WECHAT__</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">__ALIPAY__</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">App</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">Page</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">Component</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">Behavior</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">wx</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">getApp</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">getCurrentPages</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-unused-vars&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install prettier --save-dev </span><br></pre></td></tr></table></figure>
<p>新增 prettierrc.js 文件，配置如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">eslintIntegration</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">stylelintIntegration</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">tabWidth</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">singleQuote</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">semi</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>执行 lint-stage 的安装配置命令，此命令会同时安装并配置 husky </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx mrm lint-staged</span><br></pre></td></tr></table></figure>

<p>最终 package.json 文件相关配置如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span>: <span class="string">&quot;^7.15.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;husky&quot;</span>: <span class="string">&quot;^4.3.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint-staged&quot;</span>: <span class="string">&quot;^10.5.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;prettier&quot;</span>: <span class="string">&quot;^2.2.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;stylelint&quot;</span>: <span class="string">&quot;^13.8.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;stylelint-config-standard&quot;</span>: <span class="string">&quot;^20.0.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;npm run lint:js &amp;&amp; npm run lint:style &amp;&amp; npm run lint:prettier&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint:js&quot;</span>: <span class="string">&quot;eslint --fix \&quot;**/*.js\&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint:style&quot;</span>: <span class="string">&quot;stylelint --fix \&quot;**/*.wxss\&quot; --syntax css&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint:prettier&quot;</span>: <span class="string">&quot;prettier --write \&quot;**/*.(js|wxss|json)\&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;*.js&quot;</span>: <span class="string">&quot;eslint --fix&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;*.wxss&quot;</span>: <span class="string">&quot;stylelint --fix --syntax css&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;*.&#123;js,wxss,md&#125;&quot;</span>: <span class="string">&quot;prettier --write&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里同时引入了 stylelint 用来校验 wxss</p>
</blockquote>
]]></content>
      <categories>
        <category>standard</category>
      </categories>
      <tags>
        <tag>standard</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 使用笔记</title>
    <url>/2021/10/11/TypeScript-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>ts 报错默认使用 vscode locale 语言，这样可能不太容易在 google 中查询报错原因，使用如下命令将报错提示设置为英文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsc --locale en</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>2022前端建设-技术篇</title>
    <url>/2022/02/14/2022%E5%89%8D%E7%AB%AF%E5%BB%BA%E8%AE%BE-%E6%8A%80%E6%9C%AF%E7%AF%87/</url>
    <content><![CDATA[<p>方向</p>
<span id="more"></span>

<p>丰富项目 seed 模版，深入探索模版渲染技术，开发高效脚手架，示例交互项目</p>
<h2 id="规范建设"><a href="#规范建设" class="headerlink" title="规范建设"></a>规范建设</h2><p>eslint，Gitlab 规范，CICD 规范，COMMIT 规范<br>css、html、js 规范文档，vscode setting</p>
<h2 id="技术-amp-质量性能提升"><a href="#技术-amp-质量性能提升" class="headerlink" title="技术&amp;质量性能提升"></a>技术&amp;质量性能提升</h2><p>Vue3 ts 抽象语法树 pnpm 微前端 业务组件库</p>
<h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><p>打包构建，vite，rollup</p>
<h2 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h2><p>门户，错误监控，性能监控，统计分析</p>
<h2 id="团队建设"><a href="#团队建设" class="headerlink" title="团队建设"></a>团队建设</h2><p>分享，code review，gitteam blog （hexo engine）（掘金，知乎）</p>
]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>pnpm</title>
    <url>/2021/12/25/pnpm/</url>
    <content><![CDATA[<h2 id="pnpm-create"><a href="#pnpm-create" class="headerlink" title="pnpm create"></a>pnpm create</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: pnpm create &lt;name&gt;</span><br><span class="line">       pnpm create &lt;name-without-create&gt;</span><br><span class="line">       pnpm create &lt;@scope&gt;</span><br><span class="line"></span><br><span class="line">Creates a project from a `create-*` starter kit.</span><br><span class="line"></span><br><span class="line">Visit https://pnpm.io/6.x/cli/create <span class="keyword">for</span> documentation about this <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>

<p>此命令相当于 <code>npm init</code> 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Create a package.json file</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">npm init [--force|-f|--yes|-y|--scope]</span><br><span class="line">npm init &lt;@scope&gt; (same as `npx &lt;@scope&gt;/create`)</span><br><span class="line">npm init [&lt;@scope&gt;/]&lt;name&gt; (same as `npx [&lt;@scope&gt;/]create-&lt;name&gt;`)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">[-y|--yes] [-f|--force]</span><br><span class="line">[-w|--workspace &lt;workspace-name&gt; [-w|--workspace &lt;workspace-name&gt; ...]]</span><br><span class="line">[-ws|--workspaces] [--include-workspace-root]</span><br><span class="line"></span><br><span class="line">aliases: create, innit</span><br><span class="line"></span><br><span class="line">Run <span class="string">&quot;npm help init&quot;</span> <span class="keyword">for</span> more info</span><br></pre></td></tr></table></figure>

<h3 id="npx-命令"><a href="#npx-命令" class="headerlink" title="npx 命令"></a>npx 命令</h3><blockquote>
<p><a href="https://www.ruanyifeng.com/blog/2019/02/npx.html">npx 使用</a></p>
</blockquote>
]]></content>
      <categories>
        <category>npm</category>
        <category>pnpm</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>pnpm</tag>
      </tags>
  </entry>
</search>
